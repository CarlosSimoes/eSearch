<?xml version="1.0" encoding="utf-8"?>
<!--
	////////////////////////////////////////////////////////////////////////////////
	//
	// Copyright © 2010 ESRI
	//
	// All rights reserved under the copyright laws of the United States.
	// You may freely redistribute and use this software, with or
	// without modification, provided you include the original copyright
	// and use restrictions.  See use restrictions in the file:
	// <install location>/FlexViewer/License.txt
	//
	////////////////////////////////////////////////////////////////////////////////
-->

<!-- 

Version 2.5.1.5 - 3/16/2012
* Fixed more issue with subtypes and some possible issues with integer fields

--> 
<viewer:BaseWidget xmlns:esri			="http://www.esri.com/2008/ags"
				   xmlns:fx				="http://ns.adobe.com/mxml/2009"
				   xmlns:s				="library://ns.adobe.com/flex/spark"
				   xmlns:mx				="library://ns.adobe.com/flex/mx"
				   xmlns:mxeffects     	="com.adobe.ac.mxeffects.*"
				   xmlns:viewer        	="com.esri.viewer.*"
				   xmlns:Search       	="widgets.eSearch.*"
				   xmlns:supportClasses ="com.esri.ags.tasks.supportClasses.*"
				   currentState			="textInput"
				   widgetConfigLoaded	="init()" >
	<viewer:states>
		<s:State name="graphicalInput"/>
		<s:State name="textInput"/>
		<s:State name="spatialInput" />
		<s:State name="resultsList"/>
	</viewer:states>
	
	<viewer:transitions>
		<s:Transition autoReverse="true" toState="*">
			<s:Fade targets="{[graphicalInput, textInput, spatialInput, resultsList]}"/>
		</s:Transition>
	</viewer:transitions>
	
	<fx:Declarations>
		<s:GlowFilter id="glowFilter"
					  alpha="1"
					  color="{getStyle('focusColor')}"
					  inner="true"
					  strength="2"/>
		<esri:GeometryService id="geometryService"
							  fault="geometryService_faultHandler(event)"
							  url="http://tasks.arcgisonline.com/ArcGIS/rest/services/Geometry/GeometryServer"/>
		<s:ColorMatrixFilter id="cOver" matrix="[0.5,0.5,0.5,0,0,0.5,0.5,0.5,0,0,0.5,0.5,0.5,0,0,0,0,0,0.6,0]"/>
		<supportClasses:RelationshipQuery id="relatesQuery" outFields="[*]"/>
		<mx:DateFormatter id="iDateFormat" />
	</fx:Declarations>
	
	<fx:Script>
		<![CDATA[
			import com.esri.ags.FeatureSet;
			import com.esri.ags.Graphic;
			import com.esri.ags.Map;
			import com.esri.ags.SpatialReference;
			import com.esri.ags.events.DrawEvent;
			import com.esri.ags.events.ExtentEvent;
			import com.esri.ags.events.GeometryServiceEvent;
			import com.esri.ags.events.GraphicEvent;
			import com.esri.ags.events.GraphicsLayerEvent;
			import com.esri.ags.events.LayerEvent;
			import com.esri.ags.events.MapEvent;
			import com.esri.ags.geometry.Extent;
			import com.esri.ags.geometry.Geometry;
			import com.esri.ags.geometry.MapPoint;
			import com.esri.ags.geometry.Multipoint;
			import com.esri.ags.geometry.Polygon;
			import com.esri.ags.geometry.Polyline;
			import com.esri.ags.layers.ArcGISDynamicMapServiceLayer;
			import com.esri.ags.layers.FeatureLayer;
			import com.esri.ags.layers.GraphicsLayer;
			import com.esri.ags.layers.Layer;
			import com.esri.ags.layers.supportClasses.CodedValue;
			import com.esri.ags.layers.supportClasses.CodedValueDomain;
			import com.esri.ags.layers.supportClasses.FeatureType;
			import com.esri.ags.layers.supportClasses.Field;
			import com.esri.ags.layers.supportClasses.LayerDetails;
			import com.esri.ags.layers.supportClasses.RangeDomain;
			import com.esri.ags.layers.supportClasses.Relationship;
			import com.esri.ags.symbols.PictureMarkerSymbol;
			import com.esri.ags.symbols.SimpleFillSymbol;
			import com.esri.ags.symbols.SimpleLineSymbol;
			import com.esri.ags.symbols.SimpleMarkerSymbol;
			import com.esri.ags.symbols.Symbol;
			import com.esri.ags.tasks.GeometryService;
			import com.esri.ags.tasks.GeometryServiceSingleton;
			import com.esri.ags.tasks.QueryTask;
			import com.esri.ags.tasks.supportClasses.BufferParameters;
			import com.esri.ags.tasks.supportClasses.Query;
			import com.esri.ags.tools.DrawTool;
			import com.esri.ags.utils.GeometryUtil;
			import com.esri.ags.utils.GraphicUtil;
			import com.esri.ags.webmap.PopUpRenderer;
			import com.esri.ags.webmap.supportClasses.PopUpInfo;
			import com.esri.ags.webmap.supportClasses.PopUpMediaInfo;
			import com.esri.viewer.AppEvent;
			import com.esri.viewer.ViewerContainer;
			import com.esri.viewer.components.TitlebarButton;
			import com.esri.viewer.components.toc.utils.MapUtil;
			
			import mx.collections.*;
			import mx.controls.Alert;
			import mx.controls.ToolTip;
			import mx.core.FlexGlobals;
			import mx.core.IToolTip;
			import mx.core.IUIComponent;
			import mx.core.UIComponent;
			import mx.events.FlexEvent;
			import mx.events.ListEvent;
			import mx.events.ScrollEvent;
			import mx.events.ToolTipEvent;
			import mx.events.ValidationResultEvent;
			import mx.formatters.CurrencyFormatter;
			import mx.formatters.DateFormatter;
			import mx.formatters.NumberFormatter;
			import mx.managers.PopUpManager;
			import mx.managers.PopUpManagerChildList;
			import mx.managers.ToolTipManager;
			import mx.rpc.AsyncResponder;
			import mx.rpc.Fault;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			import mx.utils.ObjectUtil;
			import mx.utils.StringUtil;
			import mx.validators.NumberValidator;
			
			import spark.components.supportClasses.ItemRenderer;
			
			//labels
			[Bindable]
			private var lblbufferUserGraphic:String;
			[Bindable]
			private var noRelatesFound:String;
			[Bindable]
			private var noRelatesFoundAlertTitle:String;
			private var graphicalsearchLabel:String;
			private var textsearchLabel:String;
			private var resultsLabel:String;
			private var gridresultsLabel:String;
			[Bindable]
			private var enableMultiPartSearch:String;
			[Bindable]
			private var lblTolerance:String;
			[Bindable]
			private var layerLabel:String;
			[Bindable]
			private var layerExprLabel:String;
			private var nolayerLabel:String;
			[Bindable]	
			private var submitLabel:String;	
			[Bindable]
			private var pointLabel:String;
			[Bindable]
			private var bufferAlphaLabel:String;
			[Bindable]
			private var bufferColorLabel:String;
			[Bindable]
			private var lineLabel:String;
			[Bindable]
			private var rectangleLabel:String;
			[Bindable]
			private var polygonLabel:String;
			[Bindable]
			private var clearLabel:String;
			[Bindable]
			private var zoomallLabel:String;
			[Bindable]
			private var zoomallTip:String;
			private var loadingLabel:String;	
			private var selectionLabel:String;		
			[Bindable]
			private var drawGraLabel:String;
			[Bindable]
			private var bufferGraLabel:String;
			[Bindable]
			private var msgVisible:Boolean = false;
			[Bindable]
			private var searchLayerLabel:String;
			[Bindable]
			private var relatLayerWhereLabel:String;
			[Bindable]
			private var bufferLabel:String;
			[Bindable]
			private var drawGraphicsLayer:GraphicsLayer;
			[Bindable]
			private var bufferGraphicsLayer:GraphicsLayer;
			
			//Properties
			private var relateIcon:String;
			private var relateToolTip:String;
			[Bindable]
			private var eDrawEnabled:Boolean = false;
			[Bindable]
			private var pBufferEnabled:Boolean = false;
			[Bindable]
			private var applyBufferLabel:String;
			private var resultsFeatureSet:FeatureSet;
			private var zoomScale:Number = 5000;
			private var configSearchGraphical:Array;
			private var configSearchText:Array;
			private var configDomainVals:Array;
			private var configUserVals:Array;
			private var queryLayerRels:Array;
			private var queryLayer:FeatureLayer;
			private var relqueryLayer:FeatureLayer;
			private var queryGeom:Geometry;
			private var queryExpr:String;
			private var queryFields:XMLList;
			private var gridFields:Array = [];
			private var gridHyperFields:Array = [];
			private var relateFields:Array = [];
			private var qrelateFields:Array = [];
			private var relateHyperFields:Array = [];
			private var queryTitleField:String;
			private var qLinks:Array = [];
			private var lyrQLinks:Array = [];
			private var queryDefExpr:String = "";
			private var queryLinkIconIsField:Boolean;
			private var queryEnableExport:Boolean;
			private var timer:Timer;
			private const ICON_URL:String = "assets/images/";
			private var WIDGET_URL:String = "widgets/eSearch/assets/images/";
			private var gridDataProvider:Object;
			private var wFields:ArrayCollection;
			private var myfloatdg:SearchWidgetFloatDG;
			private var relfloatdg:SearchWidgetRelateFloatDG;
			private var sWidget:SearchWidget;
			private var _csvName:String;
			private var relatescsvName:String;
			private var fldAliases:Object;
			private var relfldAliases:Object;
			private var queryMultiImgField:String;
			private var graphicsLayerBuffer:GraphicsLayer;
			private var configSpatialSearchLayers:Array;
			private var configSpatialSearchRelation:Array;
			private var configLayerExprs:Array;
			private var configLayerRels:Array;
			private var configBufferUnits:Array;
			private var spatialsearchLabel:String;
			private var geomArr:Array;
			private var csvSep:String;
			private var expBtnLbl:String;
			private var exp2csvOptLbl:String;
			private var exp2txtOptLbl:String;
			private var queryExprForSpatRel:Boolean;
			private var sReff:SpatialReference;
			private var disableButtons:String;
			private var defaultSelectionOption:String;
			private var qLayer:FeatureLayer;
			private var layerDetails:LayerDetails;
			private var myTip:ToolTip;
			private var selectedDrawingIcon:Image;
			private var lState:String = "textInput";
			private var lblSum:String;
			private var sumField:String;
			private var pointSearchTolerance:Number = 6;
			private var popUpRenderer:PopUpRenderer = new PopUpRenderer();
			private var openDataGrid:Boolean;
			private var lastTool:String;
			private var graGraphicsLayer:GraphicsLayer;
			private var selectedGraphicalTool:String;
			[Bindable] private var multiPartGraphicSearch:Boolean;
			[Bindable] private var applyTolleranceByDefault:Boolean;
			[Bindable] private var widgetAndGridIteract:Boolean;
			
			private var executingURLquery:Boolean;
			
			private var floatorfixed:String;
			
			private var numberValidator:NumberValidator;
			
			private var rWindow:RelatesWindow;
			
			[Bindable]
			private var searchResultAC:ArrayCollection;
			//Formatters
			[Bindable]
			private var graphicsLayer:GraphicsLayer;
			private var dateFormatter:DateFormatter = new DateFormatter();
			private var numFormatter:NumberFormatter = new NumberFormatter();
			private var currFormatter:CurrencyFormatter = new CurrencyFormatter();
			
			//Symbols
			private var drawSymbol:Symbol;
			private var resultMarkerSymbol:Symbol;
			private var resultLineSymbol:Symbol;
			private var resultFillSymbol:Symbol;
			private var overFillSymbol:Symbol;
			
			protected const VERSION:String = "2.5.1.5";
			
			protected const BUILDDATE:String = "3/16/2012";
			
			[Embed(source="assets/images/i_about.png")]
			private var iconClass:Class;
			
			[Embed(source="widgets/eSearch/assets/images/i_relate.png")]
			private var relateClass:Class;
			
			private function init():void
			{					
				sWidget = this;
				WIDGET_URL = config.substring(0,config.lastIndexOf("/")) + "/assets/images/";
				if (configXML){
					if (GeometryServiceSingleton.instance.url){
						geometryService.url = GeometryServiceSingleton.instance.url;
						geometryService.token = GeometryServiceSingleton.instance.token;
						geometryService.proxyURL = GeometryServiceSingleton.instance.proxyURL;
					}
					relateIcon = configXML.relateicon || WIDGET_URL + "i_relate.png";
					//labels
					lblbufferUserGraphic = configXML.labels.bufferusergraphics || "Buffer Graphic";
					noRelatesFound = configXML.labels.norelatesfound || "No related features found";
					noRelatesFoundAlertTitle = configXML.labels.norelatesfoundalerttitle || "No Results";
					bufferColorLabel = configXML.labels.buffercolor || "Select buffer color";
					bufferAlphaLabel = configXML.labels.bufferalpha || "Adjust buffer alpha"
					lblTolerance = configXML.labels.addtolerance || "Add search tolerance to point selection";
					drawGraLabel = configXML.labels.existingdrawgraphicslabel || "Use Existing Draw Widget Graphics";
					bufferGraLabel = configXML.labels.existingbuffergraphicslabel || "Use Existing Point Buffer Widget Graphics";
					graphicalsearchLabel = configXML.labels.graphicalsearchlabel || "Graphical Search";
					textsearchLabel = configXML.labels.textsearchlabel || "Text Search";
					resultsLabel = configXML.labels.resultslabel || "Results";
					layerLabel = configXML.labels.layerlabel || "Search Layer:";
					layerExprLabel = configXML.labels.layerfieldlabel || "Search Layer Field:";
					nolayerLabel = configXML.labels.nolayerlabel || "No search layer defined.";
					submitLabel = configXML.labels.submitlabel || "Search";
					pointLabel = configXML.labels.pointlabel || "Select by Point";
					lineLabel = configXML.labels.linelabel || "Select by Line";
					rectangleLabel = configXML.labels.rectanglelabel || "Select by Rectangle";
					polygonLabel = configXML.labels.polygonlabel || "Select by Polygon";
					clearLabel = configXML.labels.clearlabel || "Clear";
					zoomallLabel = configXML.labels.zoomalllabel || "Zoom";
					zoomallTip = configXML.labels.zoomalltip || "Zoom to all results";
					loadingLabel = configXML.labels.loadinglabel || "Loading...";
					selectionLabel = configXML.labels.selectionlabel || "Features Selected:";
					gridresultsLabel = configXML.labels.gridresultslabel || "Show Results in Grid";
					exp2csvOptLbl = configXML.labels.export2csvbuttonlabel || "Export to CSV...";
					exp2txtOptLbl = configXML.labels.export2txtbuttonlabel || "Export to Txt...";
					expBtnLbl = configXML.labels.exportbtnlabel || "Export...";
					_csvName = configXML.labels.csvdefaultname || "Selected Records";
					relatescsvName = configXML.labels.relatescsvdefaultname || "Related Records";
					csvSep = configXML.csvseparator;
					spatialsearchLabel = configXML.labels.spatialsearchlabel || "Spatial search";
					searchLayerLabel = configXML.labels.searchlayerlabel || "Search entities of:";
					bufferLabel = configXML.labels.bufferlabel || "apply a search distance:";
					applyBufferLabel = configXML.labels.applybufferlabel || "Apply buffer";
					relateToolTip = configXML.relatetooltip || "Show Relates";
					sReff = new SpatialReference(configXML.spatialreference);
					defaultSelectionOption = configXML.defaultselectionoption || "textInput";
					currentState = defaultSelectionOption;
					disableButtons = configXML.disablebuttons || "";
					selectedGraphicalTool = configXML.selectedgraphicaltool || "";
					enableMultiPartSearch = configXML.labels.enablemultipartsearch || "enable multi-part graphics";
					applyTolleranceByDefault = configXML.tolerancebydefault && configXML.tolerancebydefault == "true";
					widgetAndGridIteract = configXML.enabledatagridinteractionwithwidget && configXML.enabledatagridinteractionwithwidget == "true";
					
					configSpatialSearchRelation = [];
					var operList:XMLList = configXML..spatialrelationship;
					var sOpBtn:Image;
					for (var s:Number = 0; s < operList.length(); s++){
						var srName:String = operList[s].name;
						var srLabel:String = operList[s].label;
						var spatialRelationship:Object =
						{
							name: srName,
							label: srLabel
						};
						sOpBtn = new Image();
						sOpBtn.name = srName;
						sOpBtn.source = getSopImg(srName);
						sOpBtn.toolTip = srLabel;
						sOpBtn.addEventListener(MouseEvent.CLICK, sOpBtnClickHandler);
						sOpBtn.useHandCursor = true;
						sOpBtn.buttonMode = true;
						SpatialOps.addElement(sOpBtn);
						configSpatialSearchRelation.push(spatialRelationship);
					}
					if(operList.length() == 0){
						lblSearchLayerSpatial.visible = false;
						cboSearchLayerSpatial.visible = false;
						SpatialOps.visible = false;
						lblSearchLayerSpatial.includeInLayout = false;
						cboSearchLayerSpatial.includeInLayout = false;
						SpatialOps.includeInLayout = false;
					}
					
					eDrawEnabled = configXML.enabledrawgraphicbutton && configXML.enabledrawgraphicbutton == "true";
					pBufferEnabled = configXML.enablebuffergraphicbutton && configXML.enablebuffergraphicbutton == "true";
					multiPartGraphicSearch = configXML.multipartgraphicsearch && configXML.multipartgraphicsearch == "true";
					(multiPartGraphicSearch.valueOf() == true) ? graFeatureQueryBtn.visible = true : graFeatureQueryBtn.visible = false;
					floatorfixed = configXML.floatorfixed || "float";
					
					if(eDrawEnabled){
						eDrawBtn.filters = [cOver];
						eDrawBtn.buttonMode = eDrawBtn.useHandCursor = eDrawBtn.enabled = false;
						map.addEventListener(MapEvent.LAYER_ADD, checkForeDrawGL);					
						MapUtil.forEachMapLayer(map, function(layer:Layer):void
						{
							if(layer.name.toLowerCase() == "draw features"){
								drawGraphicsLayer = layer as GraphicsLayer;
								if(drawGraphicsLayer.numGraphics > 0)
									checkeDrawNumGras(null);
								drawGraphicsLayer.addEventListener(GraphicEvent.GRAPHIC_ADD, checkeDrawNumGras);
								drawGraphicsLayer.addEventListener(GraphicEvent.GRAPHIC_REMOVE, checkeDrawNumGras);
								drawGraphicsLayer.addEventListener(GraphicsLayerEvent.GRAPHICS_CLEAR, checkeDrawNumGras);
							}
						});
					}
					
					if(pBufferEnabled){
						pBufferBtn.filters = [cOver];
						pBufferBtn.buttonMode = pBufferBtn.useHandCursor = pBufferBtn.enabled = false;
						map.addEventListener(MapEvent.LAYER_ADD, checkForpntBufferGL);					
						MapUtil.forEachMapLayer(map, function(layer:Layer):void
						{
							if(layer.name.toLowerCase() == "buffer results"){
								bufferGraphicsLayer = layer as GraphicsLayer;
								if(bufferGraphicsLayer.numGraphics > 0)
									checkBufferNumGras(null);
								bufferGraphicsLayer.addEventListener(GraphicEvent.GRAPHIC_ADD, checkBufferNumGras);
								bufferGraphicsLayer.addEventListener(GraphicEvent.GRAPHIC_REMOVE, checkBufferNumGras);
								bufferGraphicsLayer.addEventListener(GraphicsLayerEvent.GRAPHICS_CLEAR, checkBufferNumGras);
							}
						});
					}
					
					configBufferUnits = [];
					var bufferUnitsList:XMLList = configXML..bufferunit;
					for (var b:int = 0; b < bufferUnitsList.length(); b++){
						var buffUnitName:String = bufferUnitsList[b].name;
						var buffUnitLabel:String = bufferUnitsList[b].label;
						var bufferUnit:Object =
						{
							name: buffUnitName,
							label: buffUnitLabel
						};
						configBufferUnits.push(bufferUnit);
					}
					cboGraBufferUnit.dataProvider = configBufferUnits;
										
					configSearchGraphical = [];
					configSearchText = [];
					configSpatialSearchLayers = [];
					configDomainVals = [];
					
					var lyrList:XMLList = configXML..layer;
					for (var i:Number = 0; i < lyrList.length(); i++){
						configLayerExprs = [];
						configLayerRels = [];
						var lyrURL:String = lyrList[i].url;
						var lyrLabel:String = lyrList[i].name;
						var lyrGraphicalLabel:String = lyrList[i].graphicalsearchlabel;
						var lyrRelList:XMLList = configXML.layers.layer[i]..relate;
						for (var r:Number = 0; r < lyrRelList.length(); r++){
							var lyrRelLabel:String = lyrRelList[r].@label;
							var lyrRelId:String = lyrRelList[r].@id;
							var lyrRelIcon:String = lyrRelList[r].@icon || "widgets/eSearch/assets/images/i_relate.png";
							var lyrRelFields:XMLList = lyrRelList[r].fields;
							var lyrRelEnableExport:Boolean = lyrRelList[r].@enableexport && lyrRelList[r].@enableexport == "true";
							var lyrRel:Object = {
								id: lyrRelId,
								fields: lyrRelFields,
								label: lyrRelLabel,
								enableexport: lyrRelEnableExport,
								icon: lyrRelIcon
							}
							configLayerRels.push(lyrRel);
						}
						var lyrExprList:XMLList = configXML.layers.layer[i]..expression;
						for (var j:Number = 0; j < lyrExprList.length(); j++){
							var lyrExprAlias:String = lyrExprList[j].@alias;
							var lyrTextLabel:String = lyrExprList[j].@textsearchlabel;
							var lyrExpr:String = lyrExprList[j];
							var lyrField:String = lyrExprList[j].@field;
							var lyrUserList:String = lyrExprList[j].@userlist;
							var lyrDomain:Boolean = lyrExprList[j].@usedomain && lyrExprList[j].@usedomain == "true";
							var lyrSubType:Boolean = lyrExprList[j].@fromsubtype && lyrExprList[j].@fromsubtype == "true";
							var expr:Object ={
								label: lyrExprAlias,
								textlabel: lyrTextLabel,
								expression: lyrExpr,
								field: lyrField,
								usedomain: lyrDomain,
								userlist: lyrUserList
							}
							configLayerExprs.push(expr);
						}
						var lyrDefExpr:String = lyrList[i].definitionexpression;
						var lyrFields:XMLList = lyrList[i].fields;
						var lyrTitleField:String = lyrList[i].titlefield;
						
						var lyrLinks:Array = [];
						var lyrLinkList:XMLList = lyrList[i]..link;
						for (var l:Number = 0; l < lyrLinkList.length(); l++){
							var lyrLinkAlias:String = lyrLinkList[l].@alias || "";
							var lyrLinkField:String = lyrLinkList[l].@field || "";
							var lyrLinkPre:String = lyrLinkList[l].linkprefix || "";
							var lyrLinkSuffix:String = lyrLinkList[l].linksuffix || "";
							var lyrLinkIconField:String = lyrLinkList[l].iconfield || "";
							var lyrLinkIconPre:String = lyrLinkList[l].iconprefix || "";
							var lyrLinkIconSuffix:String = lyrLinkList[l].iconsuffix || "";
							var incLinkInRslts:Boolean = lyrLinkList[l].@includeinresults && lyrLinkList[l].@includeinresults == "true";
							var linkObj:Object = {
								field: lyrLinkField,
								pre: lyrLinkPre,
								suf: lyrLinkSuffix,
								inc: incLinkInRslts,
								alias: lyrLinkAlias,
								icon: lyrLinkIconField,
								iconpre: lyrLinkIconPre,
								iconsuf: lyrLinkIconSuffix
							}
							lyrLinks.push(linkObj);
						}
						var lyrEnableExport:Boolean = lyrList[i].enableexport && lyrList[i].enableexport == "true";
						var lyrMultiImgField:String = lyrList[i].multiimagefield;
						var useProxy:Boolean = lyrList[i].useproxy && lyrList[i].useproxy == "true";
						var useAMF:String = lyrList[i].useamf;
						var openDG:Boolean = lyrList[i].autoopendatagrid && lyrList[i].autoopendatagrid == "true";
						if ((lyrList[i].zoomscale.@usegeometry) && (lyrList[i].zoomscale.@usegeometry == "true")){
							zoomScale = Number.NaN;
						}else{
							if (Number(lyrList[i].zoomscale) > 0)
								zoomScale = Number(lyrList[i].zoomscale);
						}
						
						var lyrSpatialLabel:String = lyrList[i].spatialquerylabel;
						var lyrSpatialSearchLyr:String = lyrList[i].spatialsearchlayer;
						
						var layer:FeatureLayer = new FeatureLayer(lyrURL);
						if (useProxy && configData.proxyUrl)
							layer.proxyURL = configData.proxyUrl;
						if (useAMF)
							layer.useAMF = useAMF == "true";
						if (lyrFields && lyrFields[0].@all[0] == "true"){
							layer.outFields = ["*"];
						}else if (lyrFields){
							var fields:XMLList = lyrFields.field;
							layer.outFields = [];
							for each (var fieldXML:XML in fields){
								if (fieldXML.@name[0])
									layer.outFields.push(fieldXML.@name[0]);
							}
						}
						
						var searchLayer:Object = {
							layer: layer,
							label: lyrLabel,
							titlefield: lyrTitleField,
							spatialsearchlabel: lyrSpatialLabel,
							spatialsearchlayer: lyrSpatialSearchLyr,
							graphicallabel: lyrGraphicalLabel,
							expr: configLayerExprs,
							fields: lyrFields,
							links: lyrLinks,
							multi: lyrMultiImgField,
							zoomscale: zoomScale,
							enableexport: lyrEnableExport,
							defexpr: lyrDefExpr,
							opendg: openDG,
							relates: configLayerRels
						}
						configSearchGraphical.push(searchLayer);
						
						if (searchLayer.spatialsearchlayer == "true")
							configSpatialSearchLayers.push(searchLayer);
						
						if (lyrExpr){
							configSearchText.push(searchLayer);
							if(i==0){
								qLayer = new FeatureLayer(lyrURL);
								if(configLayerExprs[0].usedomain)
									popCBwithDomain(configLayerExprs[0].field);
								else if(configLayerExprs[0].userlist != "")
									popCBwithUserList(configLayerExprs[0].userlist);
							}
						}
					}
					
					//marker symbol
					if(configXML.symbols.picturemarkersymbol.@url[0] != null){
						const resultMarkerSymbolURL:String = configXML.symbols.picturemarkersymbol.@url || widgetIcon;
						const resultMarkerSymbolHeight:Number = (configXML.symbols.picturemarkersymbol.@height[0] != null) ? configXML.symbols.picturemarkersymbol.@height : 30;
						const resultMarkerSymbolWidth:Number = (configXML.symbols.picturemarkersymbol.@width[0] != null) ? configXML.symbols.picturemarkersymbol.@width : 30;
						const resultMarkerSymbolXOffset:Number = configXML.symbols.picturemarkersymbol.@xoffset || 0;
						const resultMarkerSymbolYOffset:Number = configXML.symbols.picturemarkersymbol.@yoffset || 0;
						resultMarkerSymbol = new PictureMarkerSymbol(resultMarkerSymbolURL, resultMarkerSymbolWidth, resultMarkerSymbolHeight, resultMarkerSymbolXOffset, resultMarkerSymbolYOffset);
					}else{
						const resultMarkerSymbolStyle:String = configXML.symbols.simplemarkersymbol.@style || "circle";
						const resultMarkerSymbolSize:Number = (configXML.symbols.simplemarkersymbol.@size[0] != null) ? configXML.symbols.simplemarkersymbol.@size : 15;
						const resultMarkerSymbolColor:uint = (configXML.symbols.simplemarkersymbol.@color[0] != null) ? configXML.symbols.simplemarkersymbol.@color : 0xFF0000;
						const resultMarkerSymbolAlpha:Number = (configXML.symbols.simplemarkersymbol.@alpha[0] != null) ? configXML.symbols.simplemarkersymbol.@alpha : 0.8;
						const resultMarkerSymbolXOffset2:Number = configXML.symbols.simplemarkersymbol.@xoffset || 0;
						const resultMarkerSymbolYOffset2:Number = configXML.symbols.simplemarkersymbol.@yoffset || 0;
						const resultMarkerSymbolAngle:Number = configXML.symbols.simplemarkersymbol.@angle || 0;
						const resultMarkerSymbolOutlineStyle:String = configXML.symbols.simplemarkersymbol.outline.@style || "solid";
						const resultMarkerSymbolOutlineColor:uint = (configXML.symbols.simplemarkersymbol.outline.@color[0] != null) ? configXML.symbols.simplemarkersymbol.outline.@color : 0x0000ff;
						const resultMarkerSymbolOutlineAlpha:Number = (configXML.symbols.simplemarkersymbol.outline.@alpha[0] != null) ? configXML.symbols.simplemarkersymbol.outline.@alpha : 0.8;
						const resultMarkerSymbolOutlineWidth:Number = (configXML.symbols.simplemarkersymbol.outline.@width[0] != null) ? configXML.symbols.simplemarkersymbol.outline.@width : 2;
						resultMarkerSymbol = new SimpleMarkerSymbol(resultMarkerSymbolStyle,resultMarkerSymbolSize,resultMarkerSymbolColor,resultMarkerSymbolAlpha,resultMarkerSymbolXOffset2,resultMarkerSymbolYOffset2,resultMarkerSymbolAngle,new SimpleLineSymbol(resultMarkerSymbolOutlineStyle, resultMarkerSymbolOutlineColor, resultMarkerSymbolOutlineAlpha, resultMarkerSymbolOutlineWidth));
					}
					
					//line symbol
					const resultLineSymbolColor:uint = (configXML.symbols.simplelinesymbol.@color[0] != null) ? configXML.symbols.simplelinesymbol.@color : 0xFF0000;
					const resultLineSymbolAlpha:Number = (configXML.symbols.simplelinesymbol.@alpha[0] != null) ? configXML.symbols.simplelinesymbol.@alpha : 0.8;
					const resultLineSymbolWidth:Number = (configXML.symbols.simplelinesymbol.@width[0] != null) ? configXML.symbols.simplelinesymbol.@width : 2;
					resultLineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, resultLineSymbolColor, resultLineSymbolAlpha, resultLineSymbolWidth);
					
					// fill symbol
					const resultFillSymbolColor:uint = (configXML.symbols.simplefillsymbol.@color[0] != null) ? configXML.symbols.simplefillsymbol.@color : 0xFF0000;
					const resultFillSymbolAlpha:Number = (configXML.symbols.simplefillsymbol.@alpha[0] != null) ? configXML.symbols.simplefillsymbol.@alpha : 0.5; 
					const resultFillSymbolOutlineColor:uint = (configXML.symbols.simplefillsymbol.outline.@color[0] != null) ? configXML.symbols.simplefillsymbol.outline.@color : 0xFF0000;
					const resultFillSymbolOutlineAlpha:Number = (configXML.symbols.simplefillsymbol.outline.@alpha[0] != null) ? configXML.symbols.simplefillsymbol.outline.@alpha : 0.8;
					const resultFillSymbolOutlineWidth:Number = (configXML.symbols.simplefillsymbol.outline.@width[0] != null) ? configXML.symbols.simplefillsymbol.outline.@width : 2;
					resultFillSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, resultFillSymbolColor, resultFillSymbolAlpha, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, resultFillSymbolOutlineColor, resultFillSymbolOutlineAlpha, resultFillSymbolOutlineWidth));
					
					graphicsLayerBuffer = new GraphicsLayer();
					graphicsLayerBuffer.name = "Search Buffer Results";
					map.addLayer(graphicsLayerBuffer);
					
					graphicsLayer = new GraphicsLayer();
					graphicsLayer.name = "Search Results";
					graphicsLayer.symbol = resultMarkerSymbol;
					graphicsLayer.addEventListener(FlexEvent.HIDE, graphicsLayer_hideHandler);
					map.addLayer(graphicsLayer);
					
					graGraphicsLayer = new GraphicsLayer();
					graGraphicsLayer.name = "Graphical Search Layer";
					map.addLayer(graGraphicsLayer);
					
					var userTolerance:Number = Number(configXML.toleranceforpointgraphicalselection);
					if (userTolerance > 0)
						pointSearchTolerance = userTolerance;
					if (selectedGraphicalTool != "" && defaultSelectionOption == "graphicalInput")
						activateSearchTool(null, selectedGraphicalTool);
				}
				
				if(disableButtons != "")
					var dbArr:Array = disableButtons.split(",");
				
				var disText:Boolean = false;
				var disGra:Boolean = false;
				var disSpat:Boolean = false;
				var disGrid:Boolean = false;
				var disDataGrid:Boolean = false;
				if(dbArr){
					for (var d:int = 0; d<dbArr.length; d++){
						switch (dbArr[d]){
							case "text":{
								disText = true;
								break;
							}
							case "graphic":{
								disGra = true;
								break;
							}
							case "spatial":{
								disSpat = true;
								break;
							}
							case "grid":{
								disGrid = true;
								break;
							}
							case "datagrid":{
								disDataGrid = true;
								break;
							}
						}
					}
				}
				if(floatorfixed != "fixed" && !disDataGrid)
					wTemplate.addTitlebarButton(WIDGET_URL + "i_table2.png", gridresultsLabel,showGridResults,false);
				if(!disGra)
					wTemplate.addTitlebarButton(ICON_URL + "i_searchgraphical.png", graphicalsearchLabel, showStateGraphicalSearch);
				if (configSearchText.length && disText != true)
					wTemplate.addTitlebarButton(ICON_URL + "i_searchtext.png", textsearchLabel, showStateTextSearch);
				if (configSpatialSearchLayers.length && disSpat != true)
					wTemplate.addTitlebarButton(WIDGET_URL + "i_searchspatial.png", spatialsearchLabel, showStateSpatialSearch);
				if(!disGrid)
					wTemplate.addTitlebarButton(ICON_URL + "i_table.png", resultsLabel, showStateResults);
				
				//Setup Text Search
				if (configSearchText.length){
					cboLayerText.dataProvider = configSearchText;
					txtLabelText.text = configSearchText[0].expr[0].textlabel;
					if (configSearchText.length == 1)
					{
						boxText.visible = false;
						boxText.includeInLayout = false;
					}
					cboLayerExpr.dataProvider = configSearchText[0].expr;
					if (configSearchText[0].expr.length == 1)
					{
						boxTextexpr.visible = false;
						boxTextexpr.includeInLayout = false;
					}
				}else{
					boxText.visible = false;
					txtLabelText.text = nolayerLabel;
				}
				
				//Setup Graphical Search
				if (configSearchGraphical.length){
					cboLayerGraphical.dataProvider = configSearchGraphical;
					txtLabelGraphical.text = configSearchText[0].graphicallabel;
					if (configSearchGraphical.length == 1){
						boxGraphical.visible = false;
						boxGraphical.includeInLayout = false;
					}
				}else{
					boxGraphical.visible = false;
					txtLabelGraphical.text = nolayerLabel;
				}
				
				if (configSpatialSearchLayers.length){
					cboSearchLayerSpatial.dataProvider = configSpatialSearchLayers;
					cboBufferUnit.dataProvider = configBufferUnits;
				}
				
				//Determine which button to select based on the default selection option
				for(var tb:int=0; tb < wTemplate.headerToolGroup.numElements; tb++){
					var tbb:TitlebarButton = wTemplate.headerToolGroup.getElementAt(tb) as TitlebarButton;
					if(tbb.toolTip == graphicalsearchLabel && defaultSelectionOption == "graphicalInput")
						wTemplate.selectedTitlebarButtonIndex = tb;
					if(tbb.toolTip == textsearchLabel && defaultSelectionOption == "textInput")
						wTemplate.selectedTitlebarButtonIndex = tb;
					if(tbb.toolTip == spatialsearchLabel && defaultSelectionOption == "spatialInput")
						wTemplate.selectedTitlebarButtonIndex = tb;
				}
				
				AppEvent.addListener(AppEvent.DATA_PUBLISH, sharedDataUpdated);
				
				if(ViewerContainer.urlConfigParams.search != null){
					callLater(queryFromURL,[ViewerContainer.urlConfigParams.search,ViewerContainer.urlConfigParams.slayer,ViewerContainer.urlConfigParams.exprnum]);
				}
				wTemplate.visible = true;
				wTemplate.header.addEventListener(MouseEvent.CLICK, DisplayVersion);
				txtSearch.addEventListener(FlexEvent.ENTER, equeryFeaturesText);
				searchBtn.addEventListener(MouseEvent.CLICK, equeryFeaturesText);
			}
			
			private function equeryFeaturesText(evt:Event):void
			{
				queryFeaturesText();	
			}

//Added for URL Query			
			public function queryFromURL(value:String, slayerId:int = 0, exprNum:int = 0):void
			{
				//hide infowindow if any
				hideInfoWindow();
				
				executingURLquery = true;
				
				var qFields:Array;
				zoomScale = configSearchText[slayerId].zoomscale;
				queryLayer = configSearchText[slayerId].layer;
				queryExpr = configSearchText[slayerId].expr[exprNum].expression;
				queryFields = configSearchText[slayerId].fields;
				queryLayerRels = configSearchText[slayerId].relates;
				queryDefExpr = configSearchText[slayerId].defexpr;
				
				if (queryLayer && !queryLayer.loaded)
				{
					queryLayer.addEventListener(LayerEvent.LOAD, queryLayer_loadHandler);
					function queryLayer_loadHandler(event:LayerEvent):void
					{
						queryFromURL(value, slayerId, exprNum);
					}
					return;
				}
				
				var gfields:XMLList;
				sumField = "";
				gridFields = [];
				gridHyperFields = [];
				
								
				if (queryFields){
					gfields = queryFields.field;
					for each (var fieldXML:XML in gfields){
						if (fieldXML.@gridfield[0]){
							if(fieldXML.@gridfield[0]=="true"){
								if(fieldXML.@sum[0] && fieldXML.@sum[0] == "true"){
									if(fieldXML.@sumlabel[0])
										lblSum = fieldXML.@sumlabel[0];
									sumField = fieldXML.@name[0];
								}
								var str:String = fieldXML.@name[0] + "~";
								if(fieldXML.@alias[0]){
									if(fieldXML.@alias[0] == ""){
										str += "NA~";
									}else{
										str += fieldXML.@alias[0] + "~";
									}
								}else{
									str += "NA~";
								}
								if(fieldXML.@dateformat[0]){
									if(fieldXML.@dateformat[0] == ""){
										str += "NA~";
									}else{
										str += fieldXML.@dateformat[0] + "~";
									}
								}else{
									str += "NA~";
								}
								if(fieldXML.@currencyformat[0]){
									if(fieldXML.@currencyformat[0] == ""){
										str += "NA~";
									}else{
										str += fieldXML.@currencyformat[0] + "~";
									}
								}else{
									str += "NA~";
								}
								if(fieldXML.@numberformat[0]){
									if(fieldXML.@numberformat[0] == ""){
										str += "NA~";
									}else{
										str += fieldXML.@numberformat[0] + "~";
									}
								}else{
									str += "NA~";
								}
								if(fieldXML.@useutc[0]){
									if(fieldXML.@useutc[0] == "false"){
										str += "false";
									}else{
										str += "true";
									}
								}else{
									str += "NA";
								}
								gridFields.push(str);
							}
						}
						if (fieldXML.@hyperlinkgridfield[0]){
							if (fieldXML.@hyperlinkgridfield[0]=="true"){
								var str2:String = fieldXML.@name[0] + "~";
								if(fieldXML.@alias[0]){
									if(fieldXML.@alias[0] == ""){
										str2 += "NA~";
									}else{
										str2 += fieldXML.@alias[0] + "~";
									}
								}else{
									str2 += "NA~";
								}
								if(fieldXML.@hyperlinkaliastext[0]){
									if(fieldXML.@hyperlinkaliastext[0] == ""){
										str2 += "NA~";
									}else{
										str2 += fieldXML.@hyperlinkaliastext[0] + "~";
									}
								}else{
									str2 += "NA~";
								}
								if(fieldXML.@linkprefix[0]){
									if(fieldXML.@linkprefix[0] == ""){
										str2 += "NA~";
									}else{
										str2 += fieldXML.@linkprefix[0] + "~";
									}
								}else{
									str2 += "NA~";
								}
								if(fieldXML.@linksuffix[0]){
									if(fieldXML.@linksuffix[0] == ""){
										str2 += "NA";
									}else{
										str2 += fieldXML.@linksuffix[0];
									}
								}else{
									str2 += "NA";
								}
								gridHyperFields.push(str2);
							}
						}
					}
				}
				
				queryTitleField = configSearchText[slayerId].titlefield;
				qLinks = configSearchText[slayerId].links;
				queryMultiImgField = configSearchText[slayerId].multi;
				queryEnableExport = configSearchText[slayerId].enableexport;
				var fields:XMLList;
				
				if (queryLayer)
				{
					var query:Query = new Query();
					var myPattern:RegExp = /\[value\]/g;
					var expr:String;
					value = value.replace("'","''");
					expr = queryExpr.replace(myPattern, value);
					query.where = expr;
					query.outSpatialReference = map.spatialReference;
					if(queryDefExpr != "")
						queryLayer.definitionExpression = queryDefExpr;
					queryLayer.queryFeatures(query, new AsyncResponder(onResult, onFault, queryFields)); 
					showMessage(loadingLabel, true); 
					showStateResults();     
					
					// on result
					function onResult(featureSet:FeatureSet, token:XMLList = null):void                 
					{   
						try
						{
							var gid:Number = 0;
							for each (var gra:Graphic in featureSet.features){   
								var obj:Object = gra.attributes;
								if(!queryLayer.layerDetails.objectIdField){
									obj["oid"] = gid;
									gid ++;
								}else{
									obj["oid"] = gra.attributes[queryLayer.layerDetails.objectIdField];
								}
							}
							gridDataProvider = featureSet.attributes;
							resultsFeatureSet = featureSet;
							if(queryLayerRels && queryLayerRels.length > 0)
								searchResultAC = createSearchResults(featureSet, token, queryLayerRels);
							else
								searchResultAC = createSearchResults(featureSet, token);
							
							// share data
							addSharedData(widgetTitle, searchResultAC);
							showMessage(selectionLabel + " " + featureSet.features.length, false);
							msgVisible = true;
							map.cursorManager.removeBusyCursor();
							
							if(isNaN(zoomScale)){
								zoomAll();
							}else{
								if (map.scale > zoomScale)
									map.scale = zoomScale;
								map.centerAt(searchResultAC[0].point);
							}
							
							if(ViewerContainer.urlConfigParams.showdatagrid != null)
								if(ViewerContainer.urlConfigParams.showdatagrid == "true" && floatorfixed == "float")
									showGridResults();
							
							if(floatorfixed == "fixed")
							{
								var dgCongig:Object = {
									widgetTitle: widgetTitle,
									csvExportOptionLbl: exp2csvOptLbl,
									txtExportOptionLbl: exp2txtOptLbl,
									ExportButtonLbl: expBtnLbl,
									csvSeperator: csvSep,
									dgFieldAliases: fldAliases,
									csvName: _csvName,
									sumField: sumField,
									labelSum: lblSum,
									dgColumns: gridFields,
									dgHyperColumns: gridHyperFields,
									dProvider: gridDataProvider,
									graphicslayer: graphicsLayer,
									zoomScale: zoomScale,
									ownerWidget: sWidget,
									layerDetails: queryLayer.layerDetails,
									enableExport: queryEnableExport,
									widgetInteract: widgetAndGridIteract
								}
								var dgconfigArr:ArrayCollection = new ArrayCollection();
								dgconfigArr.addItem(dgCongig);
								addSharedData("configFixedDatagrid", dgconfigArr);
							}
							executingURLquery = false;
						}
						catch (error:Error)
						{
							showMessage(error.message, false);
						}
					}
					//on fault
					function onFault(info:Object, token:Object = null) : void
					{      
						showMessage(info.toString(), false);
					}
				}  
			}
//End Add	
			private function sOpBtnClickHandler(event:Event):void
			{
				intersectResults(event.currentTarget.name);
			}
			
			private function getSopImg(value:String):String
			{
				var retVal:String = ""
				switch(value)
				{
					case "esriSpatialRelIntersects":
					{
						retVal = WIDGET_URL + "i_intersect.png";
						break;
					}
					case "esriSpatialRelContains":
					{
						retVal = WIDGET_URL + "i_contain.png";
						break;
					}
					case "esriSpatialRelCrosses":
					{
						retVal = WIDGET_URL + "i_crosses.png";
						break;
					}
					case "esriSpatialRelEnvelopeIntersects":
					{
						retVal = WIDGET_URL + "i_envintersects.png";
						break;
					}
					case "esriSpatialRelIndexIntersects":
					{
						retVal = WIDGET_URL + "i_index.png";
						break;
					}
					case "esriSpatialRelOverlaps":
					{
						retVal = WIDGET_URL + "i_overlaps.png";
						break;
					}
					case "esriSpatialRelTouches":
					{
						retVal = WIDGET_URL + "i_touches.png";
						break;
					}
					case "esriSpatialRelWithin":
					{
						retVal = WIDGET_URL + "i_within.png";
						break;
					}
				}
				return retVal;
			}			
			
			private function searchLayerChangedText():void
			{
				cbSearch.visible = false;
				cbSearch.includeInLayout = false;
				txtSearch.visible = true;
				txtSearch.includeInLayout = true;
				txtSearch.restrict = null;
				txtSearch.errorString = "";
				if(numberValidator){
					numberValidator.property = "";
					numberValidator.source = null;
				}
					
				txtSearch.addEventListener(FlexEvent.ENTER, equeryFeaturesText);
				searchBtn.addEventListener(MouseEvent.CLICK, equeryFeaturesText);
				var i:Number = cboLayerText.selectedIndex;
				if(configSearchText[i].expr[0].usedomain)
					popCBwithDomain(configSearchText[i].expr[0].field);
				else if(configSearchText[i].expr[0].userlist != "")
					popCBwithUserList(configSearchText[i].expr[0].userlist);
				txtLabelText.text = configSearchText[i].expr[0].textlabel;
				cboLayerExpr.dataProvider = configSearchText[i].expr;
				if (configSearchText[i].expr.length == 1)
				{
					boxTextexpr.visible = false;
					boxTextexpr.includeInLayout = false;
				}else{
					boxTextexpr.visible = true;
					boxTextexpr.includeInLayout = true;
				}
			}
			
			private function searchLayerExprChangedText():void
			{
				var i:Number = cboLayerText.selectedIndex;
				var j:Number = cboLayerExpr.selectedIndex;
				cbSearch.visible = false;
				cbSearch.includeInLayout = false;
				txtSearch.visible = true;
				txtSearch.includeInLayout = true;
				if(numberValidator){
					numberValidator.property = "";
					numberValidator.source = null;
				}
				searchBtn.addEventListener(MouseEvent.CLICK, equeryFeaturesText);
				txtSearch.addEventListener(FlexEvent.ENTER, equeryFeaturesText);
				if(configSearchText[i].expr[j].usedomain)
					popCBwithDomain(configSearchText[i].expr[j].field);
				else if(configSearchText[i].expr[j].userlist != "")
					popCBwithUserList(configSearchText[i].expr[j].userlist);
				txtLabelText.text = configSearchText[i].expr[j].textlabel;
			}
			
			private function searchLayerChangedGraphical():void
			{
				var i:Number = cboLayerGraphical.selectedIndex;
				txtLabelGraphical.text = configSearchText[i].graphicallabel;
			}
			
			private function activateSearchTool(event:MouseEvent, lTool:String = ""):void
			{
				addSharedData("Deactivate_DrawTool", null); // to be able to deactivate drawTool on other widgets
				
				if(event){
					graGraphicsLayer.clear();
					selectedDrawingIcon = Image(event.currentTarget);
				}else{
					switch(lTool){
						case DrawTool.EXTENT :
						{
							selectedDrawingIcon = iSearchExt;
							break;
						}
						case DrawTool.POLYGON :
						{
							selectedDrawingIcon = iSearchPoly;
							break;
						}
						case DrawTool.MAPPOINT :
						{
							selectedDrawingIcon = iSearchPnt;
							break;
						}
						case DrawTool.POLYLINE :
						{
							selectedDrawingIcon = iSearchLine;
							break;
						}
						default:
						{
							selectedDrawingIcon = iSearchPnt;
						}
					}
				}
				clearSelectionFilter();
				selectedDrawingIcon.filters = [ glowFilter ];
				
				var status:String;
				var value:String = lastTool = selectedDrawingIcon.name;
				switch (value)
				{
					case DrawTool.MAPPOINT:
					{
						status = pointLabel;
						drawSymbol = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CIRCLE, 15, 0x3FAFDC, 1);
						break;
					}
					case DrawTool.POLYLINE:
					{
						status = lineLabel;
						drawSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, 0x3FAFDC, 1, 1);
						break;
					}
					case DrawTool.EXTENT:
					{
						status = rectangleLabel;
						drawSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, 0x3FAFDC, 0.5, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, 0x3FAFDC, 1, 1));
						break;
					}
					case DrawTool.POLYGON:
					{
						status = polygonLabel;
						drawSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, 0x3FAFDC, 0.5, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, 0x3FAFDC, 1, 1));
						break;
					}
				}
				setMapAction(value, status, drawSymbol, searchDrawEnd);
			}			
			
			private function searchDrawEnd(event:DrawEvent):void
			{
				activateSearchTool(null,lastTool);
				var geom:Geometry = event.graphic.geometry;
				var graGraphic:Graphic = new Graphic(geom, drawSymbol);
				graGraphicsLayer.add(graGraphic);
				if(!graMultiChk.selected){
					queryFeaturesGra();
				}
			}
			
			private function graMultiChanged():void
			{
				(graMultiChk.selected) ? graFeatureQueryBtn.visible = true : graFeatureQueryBtn.visible = false;
			}
			
			private function unionGeoms2(gl:GraphicsLayer):Geometry
			{
				var retGeom:Geometry;
				var mPoint:Multipoint = new Multipoint(null);
				mPoint.spatialReference = map.spatialReference;
				var mPoly:Polygon = new Polygon(null);
				mPoly.spatialReference = map.spatialReference;
				var mPolyL:Polyline = new Polyline(null);
				mPolyL.spatialReference = map.spatialReference;
				var rType:String;
				for each (var graphic:Graphic in gl.graphicProvider)
				{
					if(graphic.geometry.type == "esriGeometryPoint" && !addTolerance.selected)
					{
						mPoint.addPoint(graphic.geometry as MapPoint);
						rType = "point";
					}else if (graphic.geometry.type == "esriGeometryPoint" && addTolerance.selected){
						var ext2:Extent = createExtentAroundMapPoint(graphic.geometry as MapPoint, pointSearchTolerance) as Extent;
						var pA2:Array = [];
						pA2.push(new MapPoint(ext2.xmin,ext2.ymin,ext2.spatialReference));
						pA2.push(new MapPoint(ext2.xmin,ext2.ymax,ext2.spatialReference));
						pA2.push(new MapPoint(ext2.xmax,ext2.ymax,ext2.spatialReference));
						pA2.push(new MapPoint(ext2.xmax,ext2.ymin,ext2.spatialReference));
						pA2.push(new MapPoint(ext2.xmin,ext2.ymin,ext2.spatialReference));
						mPoly.addRing(pA2);
						rType = "poly";
						mPoly.spatialReference = ext2.spatialReference;
					}
					
					if(graphic.geometry.type == "esriGeometryMultipoint")
					{
						var mp:Multipoint = graphic.geometry as Multipoint
						var pnts:MapPoint;
						for (var p:int=0;p < mp.points.length; p++)
						{
							mPoint.addPoint(mp.points[p]);
						}
						rType = "point";
					}
					
					if(graphic.geometry.type == "esriGeometryPolygon")
					{
						var poly:Polygon = graphic.geometry as Polygon;
						for (var i2:int = poly.rings.length - 1; i2 >= 0; i2--)
						{
							var ringArray:Array = [];
							for (var j1:int = 0; j1 < poly.rings[i2].length; j1++)
							{
								var mp2:MapPoint = poly.getPoint(i2,j1) as MapPoint;
								mp2.spatialReference = poly.spatialReference;
								ringArray.push(mp2);
							}
							mPoly.addRing(ringArray);
						}
						rType = "poly";
						mPoly.spatialReference = poly.spatialReference;
					}
					
					if(graphic.geometry.type == "esriGeometryPolyline")
					{
						var polyl:Polyline = graphic.geometry as Polyline;
						for(var l:int=polyl.paths.length-1; l >= 0; l--)
						{
							var pathArray:Array = [];
							for (var j2:int = 0; j2 < polyl.paths[l].length; j2++)
							{
								var mp3:MapPoint = polyl.getPoint(l,j2) as MapPoint;
								mp3.spatialReference = polyl.spatialReference;
								pathArray.push(mp3);
							}
							mPolyL.addPath(pathArray);
						}
						rType = "line";
					}
					
					if(graphic.geometry.type == "esriGeometryEnvelope")
					{
						var ext:Extent = graphic.geometry as Extent;
						var pA:Array = [];
						pA.push(new MapPoint(ext.xmin,ext.ymin,ext.spatialReference));
						pA.push(new MapPoint(ext.xmin,ext.ymax,ext.spatialReference));
						pA.push(new MapPoint(ext.xmax,ext.ymax,ext.spatialReference));
						pA.push(new MapPoint(ext.xmax,ext.ymin,ext.spatialReference));
						pA.push(new MapPoint(ext.xmin,ext.ymin,ext.spatialReference));
						mPoly.addRing(pA);
						rType = "poly";
					}
				}
				
				switch(rType){
					case "point":
					{
						retGeom = mPoint;
						break;
					}
					case "poly":
					{
						retGeom = mPoly;
						break;
					}
					case "line":
					{
						retGeom = mPolyL;
						break;
					}
				}
				return retGeom;
			}
			
			private function queryFeaturesGra():void
			{
				addSharedData("Deactivate_DrawTool", null); // to be able to deactivate drawTool on other widgets
				var geom:Geometry
				var graLayAC:ArrayCollection = graGraphicsLayer.graphicProvider as ArrayCollection;
				if (graLayAC.length > 1)
					 geom = unionGeoms2(graGraphicsLayer);
				else if (graLayAC.length == 1)
					geom = (graLayAC[0] as Graphic).geometry;
				else
					return;
				
				selectedDrawingIcon = null;
				clearSelectionFilter();
				clearBuffer();
				if (geom is Polygon && GeometryUtil.polygonSelfIntersecting(geom as Polygon))
				{
					geometryService.simplify([geom], new AsyncResponder(simpResult, null));
					function simpResult(item:Object ,spatialRelat:String):void{
						var simpGeoms:Array = item as Array;
						if(bufferUserGraphic.selected){
							applyBuffer(true);
						}else{
							queryFeaturesGraphical(simpGeoms[0] as Polygon, "esriSpatialRelIntersects", configSearchGraphical[cboLayerGraphical.selectedIndex]);
						}
					}
				}else{
					//create extent around map point to improve search results
					if (geom.type == Geometry.MAPPOINT && addTolerance.selected)
					{
						geom = createExtentAroundMapPoint(geom as MapPoint, pointSearchTolerance);
					}
					if(bufferUserGraphic.selected){
						applyBuffer(true);
					}else{
						queryFeaturesGraphical(geom, "esriSpatialRelIntersects", configSearchGraphical[cboLayerGraphical.selectedIndex]);
					}
				}
				graGraphicsLayer.clear();
			}
			
			private function createExtentAroundMapPoint(centerPoint:MapPoint, tolerance:Number):Extent
			{
				var screenPoint:Point = map.toScreen(centerPoint as MapPoint);
				
				var upperLeftScreenPoint:Point = new Point(screenPoint.x - tolerance, screenPoint.y - tolerance);
				var lowerRightScreenPoint:Point = new Point(screenPoint.x + tolerance, screenPoint.y + tolerance);
				
				var upperLeftMapPoint:MapPoint = map.toMap(upperLeftScreenPoint);
				var lowerRightMapPoint:MapPoint = map.toMap(lowerRightScreenPoint);
				
				return new Extent(upperLeftMapPoint.x, upperLeftMapPoint.y, lowerRightMapPoint.x, lowerRightMapPoint.y, map.spatialReference);
			}
			
			//query features text
			private function queryFeaturesText():void
			{
				//hide infowindow if any
				hideInfoWindow();
				
				var i:int = cboLayerText.selectedIndex;
				queryLayer = configSearchText[i].layer;

				if (queryLayer && !queryLayer.loaded)
				{
					queryLayer.addEventListener(LayerEvent.LOAD, queryLayer_loadHandler);
					function queryLayer_loadHandler(event:LayerEvent):void
					{
						queryFeaturesText()
					}
					return;
				}
				var oidFld:String = queryLayer.layerDetails.objectIdField;
				
				var qFields:Array;
				zoomScale = configSearchText[i].zoomscale;
				queryLayer = configSearchText[i].layer;
				var j:Number = cboLayerExpr.selectedIndex;
				queryExpr = configSearchText[i].expr[j].expression;
				queryFields = configSearchText[i].fields;
				queryDefExpr = configSearchText[i].defexpr;
				queryLayerRels = configSearchText[i].relates;
				var gfields:XMLList;
				sumField = "";
				gridFields = [];
				gridHyperFields = [];
				if (queryFields){
					gfields = queryFields.field;
					for each (var fieldXML:XML in gfields){
						if (fieldXML.@gridfield[0]){
							if(fieldXML.@gridfield[0]=="true"){
								if(fieldXML.@sum[0] && fieldXML.@sum[0] == "true"){
									if(fieldXML.@sumlabel[0])
										lblSum = fieldXML.@sumlabel[0];
									sumField = fieldXML.@name[0];
								}
								var str:String = fieldXML.@name[0] + "~";
								if(fieldXML.@alias[0]){
									if(fieldXML.@alias[0] == ""){
										str += "NA~";
									}else{
										str += fieldXML.@alias[0] + "~";
									}
								}else{
									str += "NA~";
								}
								if(fieldXML.@dateformat[0]){
									if(fieldXML.@dateformat[0] == ""){
										str += "NA~";
									}else{
										str += fieldXML.@dateformat[0] + "~";
									}
								}else{
									str += "NA~";
								}
								if(fieldXML.@currencyformat[0]){
									if(fieldXML.@currencyformat[0] == ""){
										str += "NA~";
									}else{
										str += fieldXML.@currencyformat[0] + "~";
									}
								}else{
									str += "NA~";
								}
								if(fieldXML.@numberformat[0]){
									if(fieldXML.@numberformat[0] == ""){
										str += "NA~";
									}else{
										str += fieldXML.@numberformat[0] + "~";
									}
								}else{
									str += "NA~";
								}
								if(fieldXML.@useutc[0]){
									if(fieldXML.@useutc[0] == "false"){
										str += "false";
									}else{
										str += "true";
									}
								}else{
									str += "NA";
								}
								gridFields.push(str);
							}
						}
						if (fieldXML.@hyperlinkgridfield[0]){
							if (fieldXML.@hyperlinkgridfield[0]=="true"){
								var str2:String = fieldXML.@name[0] + "~";
								if(fieldXML.@alias[0]){
									if(fieldXML.@alias[0] == ""){
										str2 += "NA~";
									}else{
										str2 += fieldXML.@alias[0] + "~";
									}
								}else{
									str2 += "NA~";
								}
								if(fieldXML.@hyperlinkaliastext[0]){
									if(fieldXML.@hyperlinkaliastext[0] == ""){
										str2 += "NA~";
									}else{
										str2 += fieldXML.@hyperlinkaliastext[0] + "~";
									}
								}else{
									str2 += "NA~";
								}
								if(fieldXML.@linkprefix[0]){
									if(fieldXML.@linkprefix[0] == ""){
										str2 += "NA~";
									}else{
										str2 += fieldXML.@linkprefix[0] + "~";
									}
								}else{
									str2 += "NA~";
								}
								if(fieldXML.@linksuffix[0]){
									if(fieldXML.@linksuffix[0] == ""){
										str2 += "NA";
									}else{
										str2 += fieldXML.@linksuffix[0];
									}
								}else{
									str2 += "NA";
								}
								gridHyperFields.push(str2);
							}
						}
					}
				}
				
				queryTitleField = configSearchText[i].titlefield;
				qLinks = configSearchText[i].links;
				queryMultiImgField = configSearchText[i].multi;
				queryEnableExport = configSearchText[i].enableexport;
				openDataGrid = configSearchText[i].opendg;

				var fields:XMLList;
				if ((queryLayer) && (txtSearch.text || cbSearch.text))
				{
					var query:Query = new Query();
					var myPattern:RegExp = /\[value\]/g;
					var expr:String;
					var eVal:String;
					if (txtSearch.visible){
						if(queryExpr != "[value]")//meaning an open SQL expression
							eVal = txtSearch.text.replace("'","''");
						else
							eVal = txtSearch.text;
						expr = queryExpr.replace(myPattern, eVal); 
					}else{
						eVal = cbSearch.selectedItem.value.replace("'","''");
						expr = queryExpr.replace(myPattern, eVal); 
					}
					query.where = expr;
					query.outSpatialReference = map.spatialReference;
					if(queryDefExpr != "")
						queryLayer.definitionExpression = queryDefExpr; 
					queryLayer.queryFeatures(query, new AsyncResponder(onResult, onFault, queryFields));
					showMessage(loadingLabel, true); 
					showStateResults();   
					// on result
					function onResult(featureSet:FeatureSet, token:XMLList = null):void                
					{   
						try
						{ 
							var gid:Number = 0;
							for each (var gra:Graphic in featureSet.features){   
								var obj:Object = gra.attributes;
								if(!queryLayer.layerDetails.objectIdField){
									obj["oid"] = gid;
									gid ++;
								}else{
									obj["oid"] = gra.attributes[queryLayer.layerDetails.objectIdField];
								}
							}
							gridDataProvider = featureSet.attributes;
							resultsFeatureSet = featureSet;
							if(queryLayerRels && queryLayerRels.length > 0)
								searchResultAC = createSearchResults(featureSet, token, queryLayerRels);
							else
								searchResultAC = createSearchResults(featureSet, token);
							// share data
							addSharedData(widgetTitle, searchResultAC);
							showMessage(selectionLabel + " " + featureSet.features.length, false);
							if(floatorfixed == "float"){
								if (myfloatdg){
									if(myfloatdg.datagrid.dataProvider)
										myfloatdg.datagrid.dataProvider.removeAll();
									myfloatdg.csvExportOptionLbl = exp2csvOptLbl;
									myfloatdg.txtExportOptionLbl = exp2txtOptLbl;
									myfloatdg.ExportButtonLbl = expBtnLbl;
									myfloatdg.csvSeperator = csvSep;
									myfloatdg.dgFieldAliases = fldAliases;
									myfloatdg.csvName = _csvName;
									myfloatdg.sumField = sumField;
									myfloatdg.labelSum = lblSum;
									myfloatdg.dgColumns = gridFields;
									myfloatdg.dgHyperColumns = gridHyperFields;
									myfloatdg.dProvider = gridDataProvider;
									myfloatdg.graphicslayer = graphicsLayer;
									myfloatdg.zoomScale = zoomScale;
									myfloatdg.ownerWidget = sWidget;
									myfloatdg.layerDetails = queryLayer.layerDetails;
									myfloatdg.enableExport = queryEnableExport;
									myfloatdg.widgetInteract = widgetAndGridIteract;
								}
							}else if(floatorfixed == "fixed"){
								if(!gridFields)
									gridFields = configSearchText[i].gridfields;
								var dgCongig:Object = {
									widgetTitle: widgetTitle,
									csvExportOptionLbl: exp2csvOptLbl,
									txtExportOptionLbl: exp2txtOptLbl,
									ExportButtonLbl: expBtnLbl,
									csvSeperator: csvSep,
									dgFieldAliases: fldAliases,
									csvName: _csvName,
									sumField: sumField,
									labelSum: lblSum,
									dgColumns: gridFields,
									dgHyperColumns: gridHyperFields,
									dProvider: gridDataProvider,
									graphicslayer: graphicsLayer,
									zoomScale: zoomScale,
									ownerWidget: sWidget,
									layerDetails: queryLayer.layerDetails,
									enableExport: queryEnableExport,
									widgetInteract: widgetAndGridIteract
								}
								var dgconfigArr:ArrayCollection = new ArrayCollection();
								dgconfigArr.addItem(dgCongig);
								addSharedData("configFixedDatagrid", dgconfigArr);
							}
							
							if (openDataGrid && floatorfixed != "fixed")
								showGridResults(); 
						}
						catch (error:Error)
						{
							showMessage(error.message, false);
						}
					}
					
					//on fault
					function onFault(info:Object, token:Object = null) : void
					{                    
						showMessage(info.toString(), false);         
					}
				}  
			}				
			
			//query features graphical
			private function queryFeaturesGraphical(geom:Geometry, querySpatialRel:String, layerConfig:Object):void
			{
				//hide infowindow if any
				hideInfoWindow();
				
				var qFields:Array;
				queryLayer = layerConfig.layer;
				var oidFld:String = queryLayer.layerDetails.objectIdField;
				queryGeom = geom;
				zoomScale = layerConfig.zoomscale;
				queryFields = layerConfig.fields;
				queryExpr = layerConfig.expr;
				var gfields:XMLList;
				gridFields = [];
				gridHyperFields = [];
				sumField = "";
				if (queryFields){
					gfields = queryFields.field;
					for each (var fieldXML:XML in gfields){
						if (fieldXML.@gridfield[0]){
							if(fieldXML.@gridfield[0]=="true"){
								if(fieldXML.@sum[0] && fieldXML.@sum[0] == "true"){
									if(fieldXML.@sumlabel[0])
										lblSum = fieldXML.@sumlabel[0];
									sumField = fieldXML.@name[0];
								}
								var str:String = fieldXML.@name[0] + "~";
								if(fieldXML.@alias[0]){
									if(fieldXML.@alias[0] == ""){
										str += "NA~";
									}else{
										str += fieldXML.@alias[0] + "~";
									}
								}else{
									str += "NA~";
								}
								if(fieldXML.@dateformat[0]){
									if(fieldXML.@dateformat[0] == ""){
										str += "NA~";
									}else{
										str += fieldXML.@dateformat[0] + "~";
									}
								}else{
									str += "NA~";
								}
								if(fieldXML.@currencyformat[0]){
									if(fieldXML.@currencyformat[0] == ""){
										str += "NA~";
									}else{
										str += fieldXML.@currencyformat[0] + "~";
									}
								}else{
									str += "NA~";
								}
								if(fieldXML.@numberformat[0]){
									if(fieldXML.@numberformat[0] == ""){
										str += "NA~";
									}else{
										str += fieldXML.@numberformat[0] + "~";
									}
								}else{
									str += "NA~";
								}
								if(fieldXML.@useutc[0]){
									if(fieldXML.@useutc[0] == "false"){
										str += "false";
									}else{
										str += "true";
									}
								}else{
									str += "NA";
								}
								gridFields.push(str);
							}
						}
						if (fieldXML.@hyperlinkgridfield[0]){
							if (fieldXML.@hyperlinkgridfield[0]=="true"){
								var str2:String = fieldXML.@name[0] + "~";
								if(fieldXML.@alias[0]){
									if(fieldXML.@alias[0] == ""){
										str2 += "NA~";
									}else{
										str2 += fieldXML.@alias[0] + "~";
									}
								}else{
									str2 += "NA~";
								}
								if(fieldXML.@hyperlinkaliastext[0]){
									if(fieldXML.@hyperlinkaliastext[0] == ""){
										str2 += "NA~";
									}else{
										str2 += fieldXML.@hyperlinkaliastext[0] + "~";
									}
								}else{
									str2 += "NA~";
								}
								if(fieldXML.@linkprefix[0]){
									if(fieldXML.@linkprefix[0] == ""){
										str2 += "NA~";
									}else{
										str2 += fieldXML.@linkprefix[0] + "~";
									}
								}else{
									str2 += "NA~";
								}
								if(fieldXML.@linksuffix[0]){
									if(fieldXML.@linksuffix[0] == ""){
										str2 += "NA";
									}else{
										str2 += fieldXML.@linksuffix[0];
									}
								}else{
									str2 += "NA";
								}
								gridHyperFields.push(str2);
							}
						}
					}
				}
				queryTitleField = layerConfig.titlefield;
				qLinks = layerConfig.links;
				//queryLinkIconIsField = layerConfig.linkiconisfield;
				queryMultiImgField = layerConfig.multi;
				queryExprForSpatRel = layerConfig.useforspatial;
				queryEnableExport = layerConfig.enableexport;
				queryDefExpr = layerConfig.defexpr;
				openDataGrid = layerConfig.opendg;
				queryLayerRels = layerConfig.relates;
				
				var fields:XMLList;
				if (queryLayer){
					var query:Query = new Query();
					query.geometry = queryGeom;
					query.returnGeometry = true;
					query.spatialRelationship = querySpatialRel;
					query.outSpatialReference = map.spatialReference;
					if(queryDefExpr != "")
						queryLayer.definitionExpression = queryDefExpr;
					queryLayer.queryFeatures(query, new AsyncResponder(onResult, onFault, queryFields));
					showMessage(loadingLabel, true); 
					showStateResults();   
					// on result
					function onResult(featureSet:FeatureSet, token:XMLList = null):void
					{   
						try{
							var gid:Number = 0;
							for each (var gra:Graphic in featureSet.features){   
								var obj:Object = gra.attributes;
								if(!queryLayer.layerDetails.objectIdField){
									obj["oid"] = gid;
									gid ++;
								}else{
									obj["oid"] = gra.attributes[queryLayer.layerDetails.objectIdField];
								}
							}
							gridDataProvider = featureSet.attributes;
							resultsFeatureSet = featureSet;
							if(queryLayerRels && queryLayerRels.length > 0)
								searchResultAC = createSearchResults(featureSet, token, queryLayerRels);
							else
								searchResultAC = createSearchResults(featureSet, token);
							//addSharedData(widgetTitle, searchResultAC);
							showMessage(selectionLabel + " " + featureSet.features.length, false);
							if(floatorfixed == "float"){
								if (myfloatdg){
									if(myfloatdg.datagrid.dataProvider)
										myfloatdg.datagrid.dataProvider.removeAll();
									myfloatdg.csvExportOptionLbl = exp2csvOptLbl;
									myfloatdg.txtExportOptionLbl = exp2txtOptLbl;
									myfloatdg.ExportButtonLbl = expBtnLbl;
									myfloatdg.csvSeperator = csvSep;
									myfloatdg.dgFieldAliases = fldAliases;
									myfloatdg.csvName = _csvName;
									myfloatdg.sumField = sumField;
									myfloatdg.labelSum = lblSum;
									myfloatdg.dgColumns = gridFields;
									myfloatdg.dgHyperColumns = gridHyperFields;
									myfloatdg.dProvider = gridDataProvider;
									myfloatdg.graphicslayer = graphicsLayer;
									myfloatdg.zoomScale = zoomScale;
									myfloatdg.ownerWidget = sWidget;
									myfloatdg.layerDetails = queryLayer.layerDetails;
									myfloatdg.enableExport = queryEnableExport;
									myfloatdg.widgetInteract = widgetAndGridIteract;
								}
								if (openDataGrid && floatorfixed != "fixed" )
									showGridResults();
							}else if(floatorfixed == "fixed"){
								var dgCongig:Object = {
									widgetTitle: widgetTitle,
									csvExportOptionLbl: exp2csvOptLbl,
									txtExportOptionLbl: exp2txtOptLbl,
									ExportButtonLbl: expBtnLbl,
									csvSeperator: csvSep,
									dgFieldAliases: fldAliases,
									csvName: _csvName,
									sumField: sumField,
									labelSum: lblSum,
									dgColumns: gridFields,
									dgHyperColumns: gridHyperFields,
									dProvider: gridDataProvider,
									graphicslayer: graphicsLayer,
									zoomScale: zoomScale,
									ownerWidget: sWidget,
									layerDetails: queryLayer.layerDetails,
									enableExport: queryEnableExport,
									widgetInteract: widgetAndGridIteract
								}
								var dgconfigArr:ArrayCollection = new ArrayCollection();
								dgconfigArr.addItem(dgCongig);
								addSharedData("configFixedDatagrid", dgconfigArr);
							}
						}
						catch (error:Error){
							showMessage(error.message, false);
						}	
					}
					
					//on fault
					function onFault(info:Object, token:Object = null) : void
					{                    
						showMessage(info.toString(), false);         
					}
				}
			}
			
			private function unionGeoms(featureSet:FeatureSet):Geometry
			{
				var graphic:Graphic;
				var retGeom:Geometry;
				var mPoint:Multipoint = new Multipoint(null);
				var mPoly:Polygon = new Polygon(null);
				var mPolyL:Polyline = new Polyline(null);
				var rType:String;
				for each (graphic in featureSet.features)
				{
					if(graphic.geometry.type == "esriGeometryPoint")
					{
						mPoint.addPoint(graphic.geometry as MapPoint);
						rType = "point";
					}
					
					if(graphic.geometry.type == "esriGeometryMultipoint")
					{
						var mp:Multipoint = graphic.geometry as Multipoint
						var pnts:MapPoint;
						for (var p:int=0;p < mp.points.length; p++)
						{
							mPoint.addPoint(mp.points[p]);
						}
						rType = "point";
					}
					
					if(graphic.geometry.type == "esriGeometryPolygon")
					{
						var poly:Polygon = graphic.geometry as Polygon;
						for (var i2:int = poly.rings.length - 1; i2 >= 0; i2--)
						{
							var ringArray:Array = [];
							for (var j1:int = 0; j1 < poly.rings[i2].length; j1++)
							{
								var mp2:MapPoint = poly.getPoint(i2,j1) as MapPoint;
								mp2.spatialReference = poly.spatialReference;
								ringArray.push(mp2);
							}
							mPoly.addRing(ringArray);
						}
						rType = "poly";
						mPoly.spatialReference = poly.spatialReference;
					}
					
					if(graphic.geometry.type == "esriGeometryPolyline")
					{
						var polyl:Polyline = graphic.geometry as Polyline;
						for(var l:int=polyl.paths.length-1; l >= 0; l--)
						{
							var pathArray:Array = [];
							for (var j2:int = 0; j2 < polyl.paths[l].length; j2++)
							{
								var mp3:MapPoint = polyl.getPoint(l,j2) as MapPoint;
								mp3.spatialReference = polyl.spatialReference;
								pathArray.push(mp3);
							}
							mPolyL.addPath(pathArray);
						}
						rType = "line";
					}
					
					if(graphic.geometry.type == "esriGeometryEnvelope")
					{
						var ext:Extent = graphic.geometry as Extent;
						var pA:Array = [];
						pA.push(new MapPoint(ext.xmin,ext.ymin,ext.spatialReference));
						pA.push(new MapPoint(ext.xmin,ext.ymax,ext.spatialReference));
						pA.push(new MapPoint(ext.xmax,ext.ymax,ext.spatialReference));
						pA.push(new MapPoint(ext.xmax,ext.ymin,ext.spatialReference));
						pA.push(new MapPoint(ext.xmin,ext.ymin,ext.spatialReference));
						mPoly.addRing(pA);
						rType = "poly";
					}
				}
				var graphic2:Graphic = new Graphic();
				var sfs:SimpleFillSymbol = new SimpleFillSymbol();
				sfs.color = 0x0000FF;
				sfs.alpha = 0.2;
				var sms:SimpleMarkerSymbol = new SimpleMarkerSymbol();
				sms.color = 0x0000FF;
				sms.style = SimpleMarkerSymbol.STYLE_CIRCLE;
				sms.size = 8;
				sfs.alpha = 0.4;
				var sls:SimpleLineSymbol = new SimpleLineSymbol();
				sls.color = 0x0000FF;
				sls.style = SimpleLineSymbol.STYLE_SOLID;
				sls.width = 1;
				sls.alpha = 0.4;
				
				switch(rType){
					case "point":
					{
						graphic2.geometry = mPoint;
						graphic2.symbol = sms;
						graphicsLayerBuffer.clear();
						graphicsLayerBuffer.add(graphic2);
						retGeom = mPoint;
						break;
					}
					case "poly":
					{
						graphic2.geometry = mPoly;
						graphic2.symbol = sfs;
						graphicsLayerBuffer.clear();
						graphicsLayerBuffer.add(graphic2);
						retGeom = mPoly;
						break;
					}
					case "line":
					{
						graphic2.geometry = mPolyL;
						graphic2.symbol = sls;
						graphicsLayerBuffer.clear();
						graphicsLayerBuffer.add(graphic2);
						retGeom = mPolyL;
						break;
					}
				}
				return retGeom;
			}
			
			private function applyBuffer(isGraphicalBufferOp:Boolean=false):void
			{
				var graLayAC:ArrayCollection;
				if(isGraphicalBufferOp)
					graLayAC = graGraphicsLayer.graphicProvider as ArrayCollection;
				else
					graLayAC = graphicsLayer.graphicProvider as ArrayCollection;
				
				if (graLayAC.length > 0){
					geomArr = [];
					var buffUnit:Number;
					
					if(isGraphicalBufferOp){
						for each (var graphic:Graphic in graGraphicsLayer.graphicProvider)
						{
							geomArr.push(graphic.geometry);
						}
						buffUnit = GeometryService[configBufferUnits[cboGraBufferUnit.selectedIndex].name];
						bufferGeometries(geomArr,sReff,[textGraInputBuffer.text],buffUnit,isGraphicalBufferOp);
					}else{
						for each (var graphic2:Graphic in graphicsLayer.graphicProvider)
						{
							geomArr.push(graphic2.geometry);
						}
						buffUnit = GeometryService[configBufferUnits[cboBufferUnit.selectedIndex].name];
						bufferGeometries(geomArr,sReff,[textInputBuffer.text],buffUnit,isGraphicalBufferOp);
					}
				} else {
					showStateResults();
					showMessage("There is no result to buffer, please make a graphical or text search first.",false);
				}
			}
			
			private function bufferGeometries(geomArr:Array, sr:SpatialReference, dist:Array, unit:Number, isGraphicalBufferOp:Boolean=false):void
			{
				if (geomArr)
				{
					var bufferParameters:BufferParameters = new BufferParameters();
					var resultEvent:Polygon = new Polygon;
					bufferParameters.geometries = geomArr;
					bufferParameters.bufferSpatialReference = sr;
					bufferParameters.unit = unit;
					bufferParameters.distances = dist;
					bufferParameters.unionResults = true;
					geometryService.addEventListener(GeometryServiceEvent.BUFFER_COMPLETE, bufferCompleteHandler);
					geometryService.buffer(bufferParameters);
					
					function bufferCompleteHandler(event:GeometryServiceEvent):void
					{
						geometryService.removeEventListener(GeometryServiceEvent.BUFFER_COMPLETE, bufferCompleteHandler);
						resultEvent = event.result[0];
						try
						{
							var graphic:Graphic = new Graphic();
							var sfs:SimpleFillSymbol = new SimpleFillSymbol();
							if(isGraphicalBufferOp){
								sfs.color = cpGraBufferColor.selectedColor;//0x0000FF;
								sfs.alpha = hsGraBufferAlpha.value;//0.2;
							}else{
								sfs.color = cpBufferColor.selectedColor;//0x0000FF;
								sfs.alpha = hsBufferAlpha.value;//0.2;
							}
							graphic.geometry = resultEvent;
							graphic.symbol = sfs;
							
							graphicsLayerBuffer.clear();
							graphicsLayerBuffer.add(graphic);
							if(isGraphicalBufferOp)
								queryFeaturesGraphical(resultEvent, "esriSpatialRelIntersects", configSearchGraphical[cboLayerGraphical.selectedIndex]);
						}
						catch (error:Error)
						{
							showMessage(error.message, false);
						}
					}					
				}
			}
			
			private function intersectResults(spatialRelat:String):void
			{
				geomArr = [];
				var graLayBufferAC:ArrayCollection = graphicsLayerBuffer.graphicProvider as ArrayCollection;
				var graLayAC:ArrayCollection = graphicsLayer.graphicProvider as ArrayCollection;
				var intersectGeom:Geometry;
				if (graLayBufferAC.length >0){
					var gra:Graphic = graLayBufferAC[0] as Graphic;
					intersectGeom =  gra.geometry;
					queryFeaturesGraphical(intersectGeom, spatialRelat,configSpatialSearchLayers[cboSearchLayerSpatial.selectedIndex]);
				} else if (graLayAC.length >0) {
					intersectGeom = unionGeoms(resultsFeatureSet);
					if (GeometryUtil.polygonSelfIntersecting(intersectGeom as Polygon)){
						geometryService.simplify([intersectGeom], new AsyncResponder(simpResult, null, spatialRelat));
						function simpResult(item:Object ,spatialRelat:String):void{
							var simpGeoms:Array = item as Array;
							queryFeaturesGraphical(simpGeoms[0] as Polygon, spatialRelat,configSpatialSearchLayers[cboSearchLayerSpatial.selectedIndex]);
						}
					}else{
						queryFeaturesGraphical(intersectGeom, spatialRelat,configSpatialSearchLayers[cboSearchLayerSpatial.selectedIndex]);
					}					
				} else {
					showStateResults();
					showMessage("There is no result to intersect, please make a graphical or text search first.",false);
				}
			}
			
			//create Search Results
			private function createSearchResults(featureSet:FeatureSet, queryFields:XMLList, queryRelates:Array = null):ArrayCollection
			{
				graphicsLayer.clear();
				layerDetails = queryLayer.layerDetails;
				var fields:XMLList = queryFields ? queryFields.field : null;
				
				var result:ArrayCollection = new ArrayCollection();
				if (!queryTitleField)
					queryTitleField = featureSet.displayFieldName;

				for each (var graphic:Graphic in featureSet.features){
					var value:String = "";
					var title:String = "";
					var content:String = "";
					var multi:String = "";
					fldAliases = featureSet.fieldAliases;
					lyrQLinks = [];
					
					//Go through the fields looking for the links
					var excludeLinkinResults:ArrayCollection = new ArrayCollection();
					var obj:Object = graphic.attributes;
					for (var a:int = 0; a < qLinks.length; a++){
						var link:String = "";
						var linkicon:String = "";
						var alias:String = "";
						if (queryFields && queryFields[0].@all[0] == "true"){
							if (layerDetails.fields){
								for each (var field:Field in layerDetails.fields){
									var val:String;
									try{	        	    		       
										val = obj[field.name] ? String(obj[field.name]) : "";
									} catch (error: Error){
										val = "";
									}
									if (field.name.toUpperCase() == qLinks[a].field.toUpperCase() || field.name.toUpperCase() == qLinks[a].icon.toUpperCase()){
										if (field.name.toUpperCase() == qLinks[a].field.toUpperCase()){
											if(qLinks[a].alias)
												alias = qLinks[a].alias;
											//Add the field name if the link field is to be included in the
											//results as well as used for a link.
											if(!qLinks[a].inc)
												excludeLinkinResults.addItem(qLinks[a].field.toUpperCase());
											//concatenate
											if(val != "" && val != "Null" && val != "unavailable")
												link = qLinks[a].pre + val + qLinks[a].suf;
											if( qLinks[a].iconpre != "" || qLinks[a].iconsuf != "")
												linkicon = qLinks[a].iconpre + qLinks[a].iconsuf;
											if(field.name.toUpperCase() == qLinks[a].icon.toUpperCase()){
												//concatenate
												if(val != "" && val != "Null" && val != "unavailable"){
													linkicon = qLinks[a].iconpre + val + qLinks[a].iconsuf;
												}else if(qLinks[a].iconpre != "" || qLinks[a].iconsuf != ""){
													linkicon = qLinks[a].iconpre + val + qLinks[a].iconsuf;
												}
											}
										}
									}
								}
							}else{
								for (var fieldName:String in graphic.attributes){
									var val2:String;
									try{	        	    		       
										val2 = obj[fieldName] ? String(obj[fieldName]) : "";
									} catch (error: Error){
										val2 = "";
									}
									if (fieldName.toUpperCase() == qLinks[a].field.toUpperCase() || fieldName.toUpperCase() == qLinks[a].icon.toUpperCase()){
										if (fieldName.toUpperCase() == qLinks[a].field.toUpperCase()){
											if(qLinks[a].alias)
												alias = qLinks[a].alias;
											//Add the field name if the link field is to be included in the
											//results as well as used for a link.
											if(!qLinks[a].inc)
												excludeLinkinResults.addItem(qLinks[a].field.toUpperCase());
											//concatenate
											if(val2 != "" && val2 != "Null" && val2 != "unavailable")
												link = qLinks[a].pre + val2 + qLinks[a].suf;
											if( qLinks[a].iconpre != "" || qLinks[a].iconsuf != "")
												linkicon = qLinks[a].iconpre + qLinks[a].iconsuf;
											if(field.name.toUpperCase() == qLinks[a].icon.toUpperCase()){
												//concatenate
												if(val2 != "" && val2 != "Null" && val2 != "unavailable"){
													linkicon = qLinks[a].iconpre + val2 + qLinks[a].iconsuf;
												}else if(qLinks[a].iconpre != "" || qLinks[a].iconsuf != ""){
													linkicon = qLinks[a].iconpre + val2 + qLinks[a].iconsuf;
												}
											}
										}
									}
								}
							}
						}else{
							for each (var fieldXML:XML in fields){ // display the fields in the same order as specified
								var val3:String;
								try{	        	    		       
									val3 = obj[fieldXML.@name[0]] ? String(obj[fieldXML.@name[0]]) : "";
								} catch (error: Error){
									val3 = "";
								}
								if (fieldXML.@name[0].toUpperCase() == qLinks[a].field.toUpperCase() || fieldXML.@name[0].toUpperCase() == qLinks[a].icon.toUpperCase()){
									if (fieldXML.@name[0].toUpperCase() == qLinks[a].field.toUpperCase()){
										if(qLinks[a].alias)
											alias = qLinks[a].alias;
										//Add the field name if the link field is to be included in the
										//results as well as used for a link.
										if(!qLinks[a].inc)
											excludeLinkinResults.addItem(qLinks[a].field.toUpperCase());
										//concatenate
										if(val3 != "" && val3 != "Null" && val3 != "unavailable")
											link = qLinks[a].pre + val3 + qLinks[a].suf;
										if( qLinks[a].iconpre != "" || qLinks[a].iconsuf != "")
											linkicon = qLinks[a].iconpre + qLinks[a].iconsuf;
										if(fieldXML.@name[0].toUpperCase() == qLinks[a].icon.toUpperCase()){
											//concatenate
											if(val3 != "" && val3 != "Null" && val3 != "unavailable"){
												linkicon = qLinks[a].iconpre + val3 + qLinks[a].iconsuf;
											}else if(qLinks[a].iconpre != "" || qLinks[a].iconsuf != ""){
												linkicon = qLinks[a].iconpre + val3 + qLinks[a].iconsuf;
											}
										}
									}
								}
							}
						}
						
						var lObj:Object ={
							link: link,
							icon: linkicon,
							alias: alias
						}
						lyrQLinks.push(lObj);
					}
					
					if (queryFields && queryFields[0].@all[0] == "true"){
						if (layerDetails.fields){
							for each (var field2:Field in layerDetails.fields){
								if (field2.name in graphic.attributes)
									displayFields(field2.name, getFieldXML(field2.name, fields), field2);
							}
						}else{
							for (var fieldName2:String in graphic.attributes){
								displayFields(fieldName2, getFieldXML(fieldName2, fields), null);
							}
						}
					}else{
						for each (var fieldXML2:XML in fields){ // display the fields in the same order as specified
							if (fieldXML2.@name[0] in graphic.attributes)
								displayFields(fieldXML2.@name[0], fieldXML2, getField(fieldXML2.@name[0]));
						}
					}
					
					function displayFields(fieldName:String, fieldXML:XML, field:Field):void
					{
						value = (graphic.attributes[fieldName] != null) ? String(graphic.attributes[fieldName]) : "";						
						if (value){
							var isDateField:Boolean;
							var dateFormat:String;
							var numFormat:String;
							var curFormat:String;
							var useUTC:Boolean;
							if (fieldXML){
								numFormat = fieldXML.@numberformat[0];
								curFormat = fieldXML.@currencyformat[0];
								useUTC = fieldXML.@useutc[0] == "true";
								dateFormat = fieldXML.@dateformat[0];
								if (dateFormat)
									isDateField = true;
							}
							if (!isDateField && field)
								isDateField = field.type == Field.TYPE_DATE;
							if (isDateField){
								var dateMS:Number = Number(value);
								if (!isNaN(dateMS))
									value = msToDate(dateMS, dateFormat, useUTC);
							}
							
							if(numFormat){
								var args:Array = numFormat.split("|");
								if(args[0])
									numFormatter.precision = args[0];
								if(args[1]){
									numFormatter.thousandsSeparatorFrom = args[1];
									numFormatter.thousandsSeparatorTo = args[1];
								}else{
									numFormatter.useThousandsSeparator = false;
								}
								if(args[2]){
									numFormatter.decimalSeparatorFrom = args[2];
									numFormatter.decimalSeparatorTo = args[2];
								}
								value = numFormatter.format(value);
							}
							
							if(curFormat){
								var args2:Array = curFormat.split("|");
								if(args2[0])
									currFormatter.currencySymbol = args2[0];
								if(args2[1])
									currFormatter.precision = args2[1];
								if(args2[2]){
									currFormatter.thousandsSeparatorFrom = args2[2];
									currFormatter.thousandsSeparatorTo = args2[2];
								}else{
									currFormatter.useThousandsSeparator = false;
								}
								if(args2[3]){
									currFormatter.decimalSeparatorFrom = args2[3];
									currFormatter.decimalSeparatorTo = args2[3];
								}
								value = currFormatter.format(value);
							}
							if(layerDetails && field){
								var typeID:String = layerDetails.typeIdField ? graphic.attributes[fieldName] : null;
								if (layerDetails.typeIdField && fieldName.toUpperCase() == layerDetails.typeIdField.toUpperCase()){
									// replace value with feature type name
									var featureType:FeatureType = getFeatureType(typeID);
									if (featureType && featureType.name)
										value = featureType.name;
								}else{
									// replace value with coded value name if one exists
									var codedValue:CodedValue = getCodedValue(fieldName, value, typeID);
									if (codedValue)
										value = codedValue.name;
								}
							}
						}						
						if (fieldName.toUpperCase() == queryTitleField.toUpperCase()){
							title = value;
							if (!title)
								title = widgetTitle;
						}
						if (fieldName.toUpperCase() == queryMultiImgField.toUpperCase())
							multi = value;
						if (fieldName.toUpperCase() != "SHAPE_LENGTH" 
							&& fieldName.toUpperCase() != "SHAPE_AREA"
							&& fieldName.toUpperCase() != queryMultiImgField.toUpperCase() 
							&& fieldName.toUpperCase() != queryTitleField.toUpperCase()){
							if(fieldXML){
								if(fieldXML.@gridfieldonly[0] && fieldXML.@gridfieldonly[0] == "true" || 
									fieldXML.@hyperlinkgridfieldonly[0] && fieldXML.@hyperlinkgridfieldonly[0] == "true"){
								 //ignore
								}else{
									if(!excludeLinkinResults.contains(fieldName.toUpperCase())){
										if (fieldXML && fieldXML.@alias[0])
											content += "<b>" + fieldXML.@alias[0];
										else
											content += "<b>" + featureSet.fieldAliases[fieldName];
										content += ": </b><i>" + value + "</i><br>";
									}
								}
							}else{
								if(fieldName != "oid"){
									if(!excludeLinkinResults.contains(fieldName.toUpperCase())){
										content += "<b>" + featureSet.fieldAliases[fieldName];
										content += ": </b><i>" + value + "</i><br>";
									}
								}
							} 
						}
					}						
					graphic.checkForMouseListeners = false;
					
					var searchResult:SearchResult = new SearchResult();
					searchResult.title = title;
					searchResult.content = content;
					searchResult.point = getGeomCenter(graphic);
					searchResult.links = lyrQLinks;
					searchResult.relateicon = relateIcon ? relateIcon : null;
					searchResult.geometry = graphic.geometry;
					searchResult.multi = multi ? multi :null;
					if(!queryLayer.layerDetails.objectIdField){
						searchResult.oid = graphic.attributes["oid"];
					}else{
						searchResult.oid = graphic.attributes[queryLayer.layerDetails.objectIdField];
					}
					searchResult.graphic = graphic;
					searchResult.relates = queryRelates;
					if(queryRelates && queryRelates.length == 1)
						searchResult.relateicon = queryRelates[0].icon;
					searchResult.relatetooltip = relateToolTip;
					
					switch (graphic.geometry.type){
						case Geometry.MAPPOINT:{
							graphic.symbol = searchResult.symbol = resultMarkerSymbol;
							break;
						}
						case Geometry.POLYLINE:{
							graphic.symbol = searchResult.symbol = resultLineSymbol;
							break;
						}
						case Geometry.POLYGON:{
							graphic.symbol = searchResult.symbol = resultFillSymbol;
							break;
						}
					}
					graphic.attributes = searchResult;
					result.addItem(searchResult);
				
					if (searchResult.point && !isNaN(searchResult.point.x) && !isNaN(searchResult.point.y)) // make sure it is a valid point
						graphicsLayer.add(graphic);
					// infowWindowRenderer on each graphic
					var infoWindowRenderer:ClassFactory = new ClassFactory(PopUpRenderer);
					infoWindowRenderer.properties = {popUpInfo:configurePopUpInfo(lyrQLinks)};
					graphic.infoWindowRenderer = infoWindowRenderer;
				}
				return result;
			}
			
			private function getFieldXML(fieldName:String, fields:XMLList):XML
			{
				var result:XML;
				
				for each (var fieldXML:XML in fields){
					if (fieldName == fieldXML.@name[0]){
						result = fieldXML;
						break;
					}
				}
				return result;
			}
			
			private function getField(fieldName:String):Field
			{
				var result:Field;
				
				if (queryLayer){
					for each (var field:Field in queryLayer.layerDetails.fields){
						if (fieldName == field.name){
							result = field;
							break;
						}
					}
				}
				return result;
			}
			
			private function getFeatureType(typeID:String):FeatureType
			{
				var result:FeatureType;
				
				if (queryLayer){
					for each (var featureType:FeatureType in queryLayer.layerDetails.types){
						if (typeID == featureType.id){
							result = featureType;
							break;
						}
					}
				}
				return result;
			}
			
			private function msToDate(ms:Number, dateFormat:String, useUTC:Boolean):String
			{
				var date:Date = new Date(ms);
				if (date.milliseconds == 999) // workaround for REST bug
					date.milliseconds++;
				if (useUTC)
					date.minutes += date.timezoneOffset;
				
				if (dateFormat){
					dateFormatter.formatString = dateFormat;
					var result:String = dateFormatter.format(date);
					if (result)
						return result;
					else
						return dateFormatter.error;
				}else{
					return date.toLocaleString();
				}
			}
			
			private var layerDomainsCache:Dictionary = new Dictionary(); // map from queryLayer to domainsCache
			
			private function getCodedValue(fieldName:String, fieldValue:String, typeID:String):CodedValue
			{
				var result:CodedValue;
				
				var domainsCache:Object = layerDomainsCache[queryLayer];
				if (!domainsCache){
					domainsCache = {}; // map from (fieldName + typeID) to CodedValueDomain
					layerDomainsCache[queryLayer] = domainsCache;
				}
				
				var domainsKey:String = fieldName + typeID;
				var codedValueDomain:CodedValueDomain;
				
				if (domainsKey in domainsCache){
					codedValueDomain = domainsCache[domainsKey];
				}else{
					if (typeID){
						var featureType:FeatureType = getFeatureType(typeID);
						if (featureType)
							codedValueDomain = featureType.domains[fieldName] as CodedValueDomain;
					}else{
						var field:Field = getField(fieldName);
						if (field)
							codedValueDomain = field.domain as CodedValueDomain;
					}
					domainsCache[domainsKey] = codedValueDomain;
				}
				
				if (codedValueDomain){
					for each (var codedValue:CodedValue in codedValueDomain.codedValues){
						if (fieldValue == codedValue.code){
							result = codedValue;
							break;
						}
					}
				}
				return result;
			}
			
			private function popCBwithUserList(userList:String):void
			{
				configUserVals = [];
				
				var uArray:Array = StringUtil.trimArrayElements(userList,",").split(",");
				
				for each (var val:String in uArray){
					var uval:String = val;
					var ulbl:String = val;
					var uVal:Object = 
					{
						value: uval,
						label: ulbl
					}
					configUserVals.push(uVal);
				}
				
				cbSearch.dataProvider = configUserVals;
				cbSearch.visible = true;
				cbSearch.includeInLayout = true;
				txtSearch.visible = false;
				txtSearch.includeInLayout = false;
			}
			
			private function popCBwithDomain(fieldName:String):void
			{
				configDomainVals = [];
				
				var tfield:Field;
				
				var i:int = cboLayerText.selectedIndex;
				if (i == -1){
					queryLayer = configSearchText[0].layer;
				}else{
					queryLayer = configSearchText[i].layer;
				}
				
				if (queryLayer && !queryLayer.loaded){
					queryLayer.addEventListener(LayerEvent.LOAD, queryLayer_loadHandler);
					function queryLayer_loadHandler(event:LayerEvent):void
					{
						popCBwithDomain(fieldName);
					}
					return;
				}

				var domainsCache:Object = layerDomainsCache[queryLayer];
				if (!domainsCache){
					domainsCache = {}; // map from fieldName to CodedValueDomain
					layerDomainsCache[queryLayer] = domainsCache;
				}
				
				var domainsKey:String = fieldName;
				var codedValueDomain:CodedValueDomain;
				var rangeDomain:RangeDomain;
				
				if (domainsKey in domainsCache){
					if(domainsCache[domainsKey].hasOwnProperty("codedValues"))
						codedValueDomain = domainsCache[domainsKey];
					else if (domainsCache[domainsKey].hasOwnProperty("minValue"))
						rangeDomain = domainsCache[domainsKey];
				}else{
					var field:Field = getField(fieldName);
					if (field && field.domain && field.domain.hasOwnProperty("codedValues")){
						codedValueDomain = field.domain as CodedValueDomain;
						domainsCache[domainsKey] = codedValueDomain;
					}else if (field && field.domain && field.domain.hasOwnProperty("minValue")){
						rangeDomain = field.domain as RangeDomain;
						domainsCache[domainsKey] = rangeDomain;						
					}else{
						for each (var stype:FeatureType in queryLayer.layerDetails.types){
							if(stype.domains[fieldName].hasOwnProperty("codedValues")){
								codedValueDomain = stype.domains[fieldName];
								domainsCache[domainsKey] = codedValueDomain;
							}
							else if (stype.domains[fieldName].hasOwnProperty("minValue")){
								rangeDomain = stype.domains[fieldName];
								domainsCache[domainsKey] = rangeDomain;
							}
						}
					}					
				}
				
				if(codedValueDomain){
					for each (var codedValue:CodedValue in codedValueDomain.codedValues){
						var dVal:String = codedValue.code;
						var dLbl:String = codedValue.name;
						var domVal:Object = {
							value: dVal,
							label: dLbl
						}
						configDomainVals.push(domVal);
					}
					cbSearch.prompt = "";
					cbSearch.dataProvider = configDomainVals;
					cbSearch.visible = true;
					cbSearch.editable = false;
					cbSearch.includeInLayout = true;
					txtSearch.restrict = null;
					txtSearch.errorString = "";
					if(numberValidator){
						numberValidator.property = "";
						numberValidator.source = null;
					}
					txtSearch.visible = false;
					txtSearch.includeInLayout = false;
				}
				if(rangeDomain){
					
					searchBtn.removeEventListener(MouseEvent.CLICK, equeryFeaturesText);
					
					txtSearch.removeEventListener(FlexEvent.ENTER, equeryFeaturesText);
					txtSearch.errorString = "";
					txtSearch.restrict = "0-9\\.\\-";					
					numberValidator = new NumberValidator();
					numberValidator.required = false;
					numberValidator.domain = "int";
					numberValidator.source = txtSearch;
					numberValidator.property = "text";
					numberValidator.minValue = rangeDomain.minValue;
					numberValidator.maxValue = rangeDomain.maxValue;
					numberValidator.trigger = txtSearch;
					numberValidator.triggerEvent = "enter";
					numberValidator.exceedsMaxError +=  " " + rangeDomain.minValue.toString() + " - " + rangeDomain.maxValue.toString();
					numberValidator.lowerThanMinError += " " + rangeDomain.minValue.toString() + " - " + rangeDomain.maxValue.toString();
					numberValidator.addEventListener(ValidationResultEvent.VALID, equeryFeaturesText);
					
					searchBtn.addEventListener(MouseEvent.CLICK, inputValidate);
					function inputValidate(evt:Event):void
					{
						numberValidator.validate();
					}
				}
			}

			//get geom center
			private function getGeomCenter(gra:Graphic):MapPoint
			{
				var pt:MapPoint;
				switch (gra.geometry.type){
					case Geometry.MAPPOINT:{
						pt = gra.geometry as MapPoint;
						break;
					}
					case Geometry.POLYLINE:{
						var pl:Polyline = gra.geometry as Polyline;
						var pathCount:Number = pl.paths.length;
						var pathIndex:int = int((pathCount / 2) - 1);
						var midPath:Array = pl.paths[pathIndex];
						var ptCount:Number = midPath.length;
						var ptIndex:int = int((ptCount / 2) - 1);
						pt = pl.getPoint(pathIndex, ptIndex);
						break;
					}
					case Geometry.POLYGON:{
						var poly:Polygon = gra.geometry as Polygon;
						pt = poly.extent.center;
						break;
					}
				}
				return pt;
			}			
					
			private function getDrawGra():void
			{
				if(drawGraphicsLayer){
					var geom:Geometry
					var graLayAC:ArrayCollection = drawGraphicsLayer.graphicProvider as ArrayCollection;
					if (graLayAC.length > 1){
						geom = unionGeoms2(drawGraphicsLayer);
						queryFeaturesGraphical(geom, "esriSpatialRelIntersects", configSearchGraphical[cboLayerGraphical.selectedIndex]);
					}else if (graLayAC.length == 1){
						geom = (graLayAC[0] as Graphic).geometry;
						queryFeaturesGraphical(geom, "esriSpatialRelIntersects", configSearchGraphical[cboLayerGraphical.selectedIndex]);
					}else if(drawGraphicsLayer.graphicProvider.length == 0){
						showStateResults();
						showMessage("There are no graphics available",false);
					}
				}else{
					showStateResults();
					showMessage("There are no graphics available",false);
				}
			}
			
			private function getBufferGra():void
			{
				if(bufferGraphicsLayer){
					var geom:Geometry
					var graLayAC:ArrayCollection = bufferGraphicsLayer.graphicProvider as ArrayCollection;
					if (graLayAC.length > 1){
						geom = unionGeoms2(bufferGraphicsLayer);
						queryFeaturesGraphical(geom, "esriSpatialRelIntersects", configSearchGraphical[cboLayerGraphical.selectedIndex]);
					}else if (graLayAC.length == 1){
						geom = (graLayAC[0] as Graphic).geometry;
						queryFeaturesGraphical(geom, "esriSpatialRelIntersects", configSearchGraphical[cboLayerGraphical.selectedIndex]);
					}else if(bufferGraphicsLayer.graphicProvider.length == 0){
						showStateResults();
						showMessage("There are no graphics availible",false);
					}
				} else {
					showStateResults();
					showMessage("There are no graphics availible",false);
				}
			}
			
			private function checkForeDrawGL(evt:Event):void
			{
				MapUtil.forEachMapLayer(map, function(layer:Layer):void
				{
					if(layer.name.toLowerCase() == "draw features"){
						drawGraphicsLayer = layer as GraphicsLayer;
						drawGraphicsLayer.addEventListener(GraphicEvent.GRAPHIC_ADD, checkeDrawNumGras);
						drawGraphicsLayer.addEventListener(GraphicEvent.GRAPHIC_REMOVE, checkeDrawNumGras);
						drawGraphicsLayer.addEventListener(GraphicsLayerEvent.GRAPHICS_CLEAR, checkeDrawNumGras);
					}
				});
			}
			
			private function checkeDrawNumGras(event:Event):void
			{
				if (!executingURLquery)
					clearMessage();
				if(drawGraphicsLayer){
					eDrawBtn.filters = (drawGraphicsLayer.numGraphics > 0)?[]:[cOver];
					eDrawBtn.buttonMode = eDrawBtn.useHandCursor = eDrawBtn.enabled = (drawGraphicsLayer.numGraphics > 0);
				}
			}
			
			private function checkForpntBufferGL(evt:Event):void
			{
				MapUtil.forEachMapLayer(map, function(layer:Layer):void
				{
					if(layer.name.toLowerCase() == "buffer results"){
						bufferGraphicsLayer = layer as GraphicsLayer;
						bufferGraphicsLayer.addEventListener(GraphicEvent.GRAPHIC_ADD, checkBufferNumGras);
						bufferGraphicsLayer.addEventListener(GraphicEvent.GRAPHIC_REMOVE, checkBufferNumGras);
						bufferGraphicsLayer.addEventListener(GraphicsLayerEvent.GRAPHICS_CLEAR, checkBufferNumGras);
					}
				});
			}
			
			private function checkBufferNumGras(event:Event):void
			{
				if (!executingURLquery)
					clearMessage();
				if(bufferGraphicsLayer){
					pBufferBtn.filters = (bufferGraphicsLayer.numGraphics > 0)?[]:[cOver];
					pBufferBtn.buttonMode = pBufferBtn.useHandCursor = pBufferBtn.enabled = (bufferGraphicsLayer.numGraphics > 0);
				}
			}
			
			private function clear():void
			{
				addSharedData("Deactivate_DrawTool", null); // to be able to deactivate drawTool on other widgets
				
				//hide infowindow if any
				hideInfoWindow();
				
				if(currentState == "resultsList"){
					currentState = lState;
					if(lState == "graphicalInput"){
						wTemplate.selectedTitlebarButtonIndex = 1;
					}else if (lState == "textInput"){
						wTemplate.selectedTitlebarButtonIndex = 2;
					}else{
						wTemplate.selectedTitlebarButtonIndex = 3;
					}
				}
				graphicsLayer.clear();
				graphicsLayerBuffer.clear();
				graGraphicsLayer.clear();
				clearMessage();
				txtSearch.text = "";
				txtSearch.errorString = "";
				sumField = "";
				searchResultAC = null;
				if (myfloatdg){
					myfloatdg.datagrid.dataProvider.removeAll();
					gridDataProvider = null;
				}
				if (relfloatdg)
					PopUpManager.removePopUp(relfloatdg);
				if(floatorfixed == "fixed")
					addSharedData("clearFixedDatagrid", null);
				if(floatorfixed == "fixed")
					addSharedData("clearRelateFixedDatagrid", null);
			}
			
			private function clearBuffer():void
			{
				graphicsLayerBuffer.clear();
			}		
			
			private var hitimer:uint;
			private var Hits:Array = new Array();									
			
			private function showMessage(msg:String, swfVisible:Boolean):void
			{
				txtMessage.text = msg;
				swfMessage.visible = swfVisible;
				msgVisible = true;
			}			
			
			private function clearMessage():void
			{
				msgVisible = false;
			}
			
			private function clickSearchRelateResult(event:Event):void
			{
				var relId:int;
				var relLbl:String;
				var relFields:XMLList;
				var relExportEnabled:Boolean;
				var rFields:XMLList;
				qrelateFields = [];
				relateFields = [];
				relateHyperFields = [];
				sumField = "";
				
				var searchResult:SearchResult = ItemRenderer(event.target).data as SearchResult;
				var selRelateURL:String;
				
				var relArr:Array = queryLayer.layerDetails.relationships;
				
				if(searchResult.relates.length == 1){
					var relation:Relationship;
					for (var ri:int=0; ri < relArr.length; ri++){
						if(relArr[ri].id == searchResult.relates[0].id){
							relation = relArr[ri] as Relationship;
							break;
						}
					}
					selRelateURL = queryLayer.url.substring(0,queryLayer.url.lastIndexOf("/")) + "/" + (relation.relatedTableId);
					if(!relqueryLayer)
						relqueryLayer = new FeatureLayer(selRelateURL);
					
					if (relqueryLayer && !relqueryLayer.loaded){
						relqueryLayer.addEventListener(LayerEvent.LOAD, queryLayer_loadHandler);
						function queryLayer_loadHandler(levent:LayerEvent):void
						{
							clickSearchRelateResult(event)
						}
						return;
					}
					
					relId = searchResult.relates[0].id;
					relLbl = searchResult.relates[0].label;
					relFields = searchResult.relates[0].fields;
					relExportEnabled = searchResult.relates[0].enableexport;
					if(relFields.@all[0] == "true"){
						relatesQuery.outFields = ["*"];
						relatesQuery.relationshipId = relId;
						relatesQuery.objectIds = [searchResult.oid];
						queryLayer.queryRelatedFeatures(relatesQuery, new AsyncResponder(onRelateResult, onFault, searchResult.oid));
					}else{
						rFields = relFields.field;
						for each (var fieldXML:XML in rFields){
							if(fieldXML.@sum[0] && fieldXML.@sum[0] == "true"){
								if(fieldXML.@sumlabel[0])
									lblSum = fieldXML.@sumlabel[0];
								sumField = fieldXML.@name[0];
							}
							qrelateFields.push(fieldXML.@name[0]);
							var str:String = fieldXML.@name[0] + "~";
							if(fieldXML.@alias[0]){
								if(fieldXML.@alias[0] == ""){
									str += "NA~";
								}else{
									str += fieldXML.@alias[0] + "~";
								}
							}else{
								str += "NA~";
							}
							if(fieldXML.@dateformat[0]){
								if(fieldXML.@dateformat[0] == ""){
									str += "NA~";
								}else{
									str += fieldXML.@dateformat[0] + "~";
								}
							}else{
								str += "NA~";
							}
							if(fieldXML.@currencyformat[0]){
								if(fieldXML.@currencyformat[0] == ""){
									str += "NA~";
								}else{
									str += fieldXML.@currencyformat[0] + "~";
								}
							}else{
								str += "NA~";
							}
							if(fieldXML.@numberformat[0]){
								if(fieldXML.@numberformat[0] == ""){
									str += "NA~";
								}else{
									str += fieldXML.@numberformat[0] + "~";
								}
							}else{
								str += "NA~";
							}
							if(fieldXML.@useutc[0]){
								if(fieldXML.@useutc[0] == "false"){
									str += "false";
								}else{
									str += "true";
								}
							}else{
								str += "NA";
							}
							if(!fieldXML.@hyperlinkgridfield[0])
								relateFields.push(str);
							if (fieldXML.@hyperlinkgridfield[0]){
								if (fieldXML.@hyperlinkgridfield[0]=="true"){
									var str2:String = fieldXML.@name[0] + "~";
									if(fieldXML.@alias[0]){
										if(fieldXML.@alias[0] == ""){
											str2 += "NA~";
										}else{
											str2 += fieldXML.@alias[0] + "~";
										}
									}else{
										str2 += "NA~";
									}
									if(fieldXML.@hyperlinkaliastext[0]){
										if(fieldXML.@hyperlinkaliastext[0] == ""){
											str2 += "NA~";
										}else{
											str2 += fieldXML.@hyperlinkaliastext[0] + "~";
										}
									}else{
										str2 += "NA~";
									}
									if(fieldXML.@linkprefix[0]){
										if(fieldXML.@linkprefix[0] == ""){
											str2 += "NA~";
										}else{
											str2 += fieldXML.@linkprefix[0] + "~";
										}
									}else{
										str2 += "NA~";
									}
									if(fieldXML.@linksuffix[0]){
										if(fieldXML.@linksuffix[0] == ""){
											str2 += "NA";
										}else{
											str2 += fieldXML.@linksuffix[0];
										}
									}else{
										str2 += "NA";
									}
									relateHyperFields.push(str2);
								}
							}
						}
						relatesQuery.outFields = qrelateFields;
						relatesQuery.relationshipId = relId;
						relatesQuery.objectIds = [searchResult.oid];
						queryLayer.queryRelatedFeatures(relatesQuery, new AsyncResponder(onRelateResult, onFault, searchResult.oid));
					}
				}else{
					relqueryLayer = null;
					var relArrayColl:ArrayCollection = new ArrayCollection();
					for(var r:int=0; r < searchResult.relates.length; r++){
						var relRslt:RelateResult = new RelateResult();
						relRslt.id = searchResult.relates[r].id;
						relRslt.name = searchResult.relates[r].label;
						relRslt.fields = searchResult.relates[r].fields;
						relRslt.enableexport = searchResult.relates[r].enableexport;
						relRslt.oid = searchResult.oid;
						relRslt.icon = searchResult.relates[r].icon;
						relArrayColl.addItem(relRslt);
					}
					
					if(!rWindow){
						rWindow = new RelatesWindow();
						rWindow.dProvider = relArrayColl;
						rWindow.addEventListener("relateClicked", relateChoosen);
						PopUpManager.addPopUp(rWindow,map,true,PopUpManagerChildList.POPUP);
						PopUpManager.centerPopUp(rWindow);
						PopUpManager.bringToFront(rWindow);
					}else{
						var exists:Boolean = false;
						for (var p:Number=0;p<systemManager.popUpChildren.numChildren;p++) {
							if(systemManager.popUpChildren.getChildAt(p) is RelatesWindow){
								exists = true;
								break;
							}
						}
						if(exists == false)
							PopUpManager.addPopUp(rWindow,map,true,PopUpManagerChildList.POPUP); 
						PopUpManager.centerPopUp(rWindow);
						PopUpManager.bringToFront(rWindow);
					}
					rWindow.dProvider = relArrayColl;
				}
				
				function relateChoosen(evt:Event):void{
					var relArr:Array = queryLayer.layerDetails.relationships;
					var relation:Relationship;
					for (var ri:int=0; ri < relArr.length; ri++){
						if(relArr[ri].id == rWindow.selectedRelateId){
							relation = relArr[ri] as Relationship;
							break;
						}
					}
					relId = rWindow.selectedRelateId;
					relLbl = rWindow.selectedRelateName;
					relFields = rWindow.selectedRelateFields;
					relExportEnabled = rWindow.selectedRelateExportEnabled;
					var relOid:Number = rWindow.oid;
					PopUpManager.removePopUp(rWindow);
					 
					selRelateURL = queryLayer.url.substring(0,queryLayer.url.lastIndexOf("/")) + "/" + (relation.relatedTableId);
					if(!relqueryLayer)
						relqueryLayer = new FeatureLayer(selRelateURL);
					
					if (relqueryLayer && !relqueryLayer.loaded){
						relqueryLayer.addEventListener(LayerEvent.LOAD, queryLayer_loadHandler);
						function queryLayer_loadHandler(levent:LayerEvent):void
						{
							relateChoosen(evt)
						}
						return;
					}
					
					if(relFields.@all[0] == "true"){
						relatesQuery.outFields = ["*"];
						relatesQuery.relationshipId = relId;
						relatesQuery.objectIds = [relOid];
						queryLayer.queryRelatedFeatures(relatesQuery, new AsyncResponder(onRelateResult, onFault, relOid));
					}else{
						rFields = relFields.field;
						for each (var fieldXML:XML in rFields){
							if(fieldXML.@sum[0] && fieldXML.@sum[0] == "true"){
								if(fieldXML.@sumlabel[0])
									lblSum = fieldXML.@sumlabel[0];
								sumField = fieldXML.@name[0];
							}
							qrelateFields.push(fieldXML.@name[0]);
							var str:String = fieldXML.@name[0] + "~";
							if(fieldXML.@alias[0]){
								if(fieldXML.@alias[0] == ""){
									str += "NA~";
								}else{
									str += fieldXML.@alias[0] + "~";
								}
							}else{
								str += "NA~";
							}
							if(fieldXML.@dateformat[0]){
								if(fieldXML.@dateformat[0] == ""){
									str += "NA~";
								}else{
									str += fieldXML.@dateformat[0] + "~";
								}
							}else{
								str += "NA~";
							}
							if(fieldXML.@currencyformat[0]){
								if(fieldXML.@currencyformat[0] == ""){
									str += "NA~";
								}else{
									str += fieldXML.@currencyformat[0] + "~";
								}
							}else{
								str += "NA~";
							}
							if(fieldXML.@numberformat[0]){
								if(fieldXML.@numberformat[0] == ""){
									str += "NA~";
								}else{
									str += fieldXML.@numberformat[0] + "~";
								}
							}else{
								str += "NA~";
							}
							if(fieldXML.@useutc[0]){
								if(fieldXML.@useutc[0] == "false"){
									str += "false";
								}else{
									str += "true";
								}
							}else{
								str += "NA";
							}
							if(!fieldXML.@hyperlinkgridfield[0])
								relateFields.push(str);
							if (fieldXML.@hyperlinkgridfield[0]){
								if (fieldXML.@hyperlinkgridfield[0]=="true"){
									var str2:String = fieldXML.@name[0] + "~";
									if(fieldXML.@alias[0]){
										if(fieldXML.@alias[0] == ""){
											str2 += "NA~";
										}else{
											str2 += fieldXML.@alias[0] + "~";
										}
									}else{
										str2 += "NA~";
									}
									if(fieldXML.@hyperlinkaliastext[0]){
										if(fieldXML.@hyperlinkaliastext[0] == ""){
											str2 += "NA~";
										}else{
											str2 += fieldXML.@hyperlinkaliastext[0] + "~";
										}
									}else{
										str2 += "NA~";
									}
									if(fieldXML.@linkprefix[0]){
										if(fieldXML.@linkprefix[0] == ""){
											str2 += "NA~";
										}else{
											str2 += fieldXML.@linkprefix[0] + "~";
										}
									}else{
										str2 += "NA~";
									}
									if(fieldXML.@linksuffix[0]){
										if(fieldXML.@linksuffix[0] == ""){
											str2 += "NA";
										}else{
											str2 += fieldXML.@linksuffix[0];
										}
									}else{
										str2 += "NA";
									}
									relateHyperFields.push(str2);
								}
							}
						}
						relatesQuery.outFields = qrelateFields;
						relatesQuery.relationshipId = relId;
						relatesQuery.objectIds = [relOid];
						queryLayer.queryRelatedFeatures(relatesQuery, new AsyncResponder(onRelateResult, onFault, relOid));
					}
				}
				
				function onRelateResult(relatedRecords:Object, token:Object = null):void
				{
					// get related records for the first feature
					var fset:FeatureSet = (relatedRecords[token]);
					if (!fset){
						Alert.show(noRelatesFound + " " + relLbl,noRelatesFoundAlertTitle,4,wTemplate,null,relateClass);
						return;
					}
					relfldAliases = fset.fieldAliases;
					if(relateFields.length == 0){
						var rfld:Field;
						for each (rfld in fset.fields){
							var str0:String = rfld.name + "~";
							str0 += rfld.alias + "~";
							str0 += "NA~";
							str0 += "NA~";
							str0 += "NA~";
							str0 += "NA";
							relateFields.push(str0);
						}
					}
					if (fset is FeatureSet){
						if(floatorfixed == "float"){
							if(!relfloatdg){
								relfloatdg = new SearchWidgetRelateFloatDG();
								PopUpManager.addPopUp(relfloatdg,map,false,PopUpManagerChildList.POPUP);
								PopUpManager.centerPopUp(relfloatdg);
							}else{
								var exists:Boolean = false;
								for (var p:Number=0;p<systemManager.popUpChildren.numChildren;p++) {
									if(systemManager.popUpChildren.getChildAt(p) is SearchWidgetRelateFloatDG){
										exists = true;
										break;
									}
								}
								if(exists == false){
									PopUpManager.addPopUp(relfloatdg,map,false,PopUpManagerChildList.POPUP); 
									PopUpManager.centerPopUp(relfloatdg);
								}
							}
							
							if(relfloatdg.datagrid.dataProvider)
								relfloatdg.datagrid.dataProvider.removeAll();
							relfloatdg.csvExportOptionLbl = exp2csvOptLbl;
							relfloatdg.txtExportOptionLbl = exp2txtOptLbl;
							relfloatdg.ExportButtonLbl = expBtnLbl;
							relfloatdg.csvSeperator = csvSep;
							relfloatdg.dgFieldAliases = relfldAliases;
							relfloatdg.csvName = relatescsvName;
							relfloatdg.sumField = sumField;
							relfloatdg.labelSum = lblSum;
							relfloatdg.dgColumns = relateFields;
							relfloatdg.dgHyperColumns = relateHyperFields;
							relfloatdg.layerDetails = relqueryLayer.layerDetails;
							relfloatdg.dProvider = fset.attributes;
							relfloatdg.enableExport = relExportEnabled;
							relfloatdg.dgtitle = relLbl;
						}else if(floatorfixed == "fixed"){
							var dgCongig:Object = {
								dgFieldAliases: relfldAliases,
								csvName: relatescsvName,
								sumField: sumField,
								labelSum: lblSum,
								dgColumns: relateFields,
								dgHyperColumns: relateHyperFields,
								dProvider: fset.attributes,
								layerDetails: relqueryLayer.layerDetails,
								enableExport: relExportEnabled
							}
							var dgconfigArr:ArrayCollection = new ArrayCollection();
							dgconfigArr.addItem(dgCongig);
							addSharedData("configRelateFixedDatagrid", dgconfigArr);
							addSharedData("switch2RelateTabFixedDataGrid", null);
						}
					}
				}
				
				//on fault
				function onFault(event:Fault,data:Object):void
				{                    
					Alert.show(event.faultDetail.toString(), "Fault",4,wTemplate);         
				}
			}
			
			private function clickSearchResult(event:Event):void
			{
				var recAC:ArrayCollection = searchResultDG.dataProvider as ArrayCollection;
				var searchResult:SearchResult = ItemRenderer(event.target).data as SearchResult;
				unhighlightDataGroupItems();
				searchResult.selected = true;
				
				if(lState == "textInput"){
					var i:Number = cboLayerText.selectedIndex;
					zoomScale = configSearchText[i].zoomscale;
				} else if(lState == "graphicalInput"){
					var i2:Number = cboLayerGraphical.selectedIndex;
					zoomScale = configSearchGraphical[i2].zoomscale;
				}
				
				if (searchResult.geometry){
					if (searchResult.geometry.type == Geometry.MAPPOINT){
						if (map.scale > zoomScale)
							map.scale = zoomScale;
						map.centerAt(searchResult.point);
					}else{
						if(isNaN(zoomScale)){
							map.extent = searchResult.geometry.extent;
							if (!map.extent.contains(searchResult.geometry))
								map.level--;
						}else{
							if (map.scale > zoomScale)
								map.scale = zoomScale;
							map.centerAt(searchResult.point);
						}
					}
				}
				
				Hits.length = 0;
				
				if(myfloatdg){
					if(myfloatdg.datagrid.dataProvider){
						for each(var attributes:Object in gridDataProvider){
							if (attributes.oid === searchResult.oid){
								var myCursor:IViewCursor = myfloatdg.datagrid.dataProvider.createCursor();
								while(!myCursor.afterLast){
									if(myCursor.current.oid == attributes.oid)
										Hits.push(myCursor.current);
									myCursor.moveNext();
								}
								myfloatdg.datagrid.selectedIndex = myfloatdg.datagrid.dataProvider.getItemIndex(Hits[0])                        
							}
						}                
						myfloatdg.datagrid.scrollToIndex(myfloatdg.datagrid.selectedIndex);
					}
				}
				if(floatorfixed == "fixed"){
					var dgCongig:Object = {
						searchResultoid: searchResult.oid
					}
					var dgconfigArr:ArrayCollection = new ArrayCollection();
					dgconfigArr.addItem(dgCongig);
					addSharedData("scrollFixedDataGrid", dgconfigArr);
				}
			}
			
			private function mouseOverSearchResult(event:Event):void
			{
				clearTimeout(hitimer);
				var searchResult:SearchResult = ItemRenderer(event.target).data as SearchResult;
				if (map.extent.containsXY(searchResult.point.x, searchResult.point.y)) // only show infowindow if search result in contained within map extent
					hitimer = setTimeout(showHighlight, 300, [ searchResult ]);
				else
					hideInfoWindow();
				
				Hits.length = 0;
				
				if(myfloatdg){
					if(myfloatdg.datagrid && myfloatdg.datagrid.dataProvider){
						for each(var attributes:Object in gridDataProvider){
							if (attributes.oid === searchResult.oid){
								var myCursor:IViewCursor = myfloatdg.datagrid.dataProvider.createCursor();
								while(!myCursor.afterLast){
									if(myCursor.current.oid == attributes.oid)
										Hits.push(myCursor.current);
									myCursor.moveNext();
								}
								myfloatdg.datagrid.selectedIndex = myfloatdg.datagrid.dataProvider.getItemIndex(Hits[0])                        
							}
						}                
						myfloatdg.datagrid.scrollToIndex(myfloatdg.datagrid.selectedIndex);
					}
				}
				if(floatorfixed == "fixed"){
					var dgCongig:Object = {
						searchResultoid: searchResult.oid
					}
					var dgconfigArr:ArrayCollection = new ArrayCollection();
					dgconfigArr.addItem(dgCongig);
					addSharedData("scrollFixedDataGrid", dgconfigArr);
				}
			}
			
			private function mouseOutSearchResult(event:Event):void
			{
				clearTimeout(hitimer);
			}
			
			private function widgetOpenedHandler(event:Event):void
			{
				if(graphicsLayer)
					graphicsLayer.visible = true;
				if (graphicsLayerBuffer)
					graphicsLayerBuffer.visible = true;
				if (graGraphicsLayer)
					graGraphicsLayer.visible = true;
			}
			
			private function showGridResults():void
			{
				try{
					if(gridFields.length == 0){
						showMessage("No Datagrid configured for this layer", false);
						return;
					}
					
					if(floatorfixed == "float"){
						if(!myfloatdg){
							myfloatdg = new SearchWidgetFloatDG();
							PopUpManager.addPopUp(myfloatdg,map,false,PopUpManagerChildList.POPUP)
							PopUpManager.centerPopUp(myfloatdg);
						}else{
							var exists:Boolean = false;
							for (var p:Number=0;p<systemManager.popUpChildren.numChildren;p++) {
								if(systemManager.popUpChildren.getChildAt(p) is SearchWidgetFloatDG){
									exists = true;
									break;
								}
							}
							if(exists == false)
								PopUpManager.addPopUp(myfloatdg,map,false,PopUpManagerChildList.POPUP); 
							PopUpManager.centerPopUp(myfloatdg);
						}
						if(!gridFields)
							gridFields = configSearchText[0].gridfields;
						myfloatdg.enableExport = configSearchText[0].enableexport;
						myfloatdg.layerDetails = queryLayer.layerDetails;
						myfloatdg.csvSeperator = csvSep;
						myfloatdg.csvExportOptionLbl = exp2csvOptLbl;
						myfloatdg.txtExportOptionLbl = exp2txtOptLbl;
						myfloatdg.ExportButtonLbl = expBtnLbl;
						myfloatdg.csvName = _csvName;
						myfloatdg.sumField = sumField;
						myfloatdg.labelSum = lblSum;
						myfloatdg.dgFieldAliases = fldAliases;
						myfloatdg.dgColumns = gridFields;
						myfloatdg.dgHyperColumns = gridHyperFields;
						myfloatdg.dProvider = gridDataProvider;
						myfloatdg.graphicslayer = graphicsLayer;
						myfloatdg.widgetInteract = widgetAndGridIteract;
						if(lState == "graphicalInput"){
							var i2:Number = cboLayerGraphical.selectedIndex;
							zoomScale = configSearchGraphical[i2].zoomscale;
							myfloatdg.enableExport = configSearchGraphical[i2].enableexport;
						}else if (lState == "textInput"){
							var i:Number = cboLayerText.selectedIndex;
							zoomScale = configSearchText[i].zoomscale;
							myfloatdg.enableExport = configSearchText[i].enableexport;
						}
						myfloatdg.zoomScale = zoomScale;
						myfloatdg.ownerWidget = this;
					}
					
				}
				catch (error:Error){
					showMessage(error.message, false);
				}
			}
			
			public function highlightDataGroupItem(gra:Graphic):void
			{
				if(widgetAndGridIteract){
					var recAC:ArrayCollection = searchResultDG.dataProvider as ArrayCollection;
					if(gra){
						var sr:SearchResult = gra.attributes as SearchResult;						
						for (var i:Number = 0; i < recAC.length; i++){
							var sr1:SearchResult = searchResultAC[i];
							if(sr1.oid === sr.oid){
								sr1.selected = true;
								if(searchResultDG.getItemIndicesInView().length > 0)
									searchResultDG.verticalScrollPosition = searchResultDG.getElementAt(searchResultDG.getItemIndicesInView()[0]).height * i;
								break;
							}
						}
					}
				}
			}
			
			public function clearSelected():void
			{
				var recAC:ArrayCollection = searchResultDG.dataProvider as ArrayCollection;
				if(recAC){
					for (var i:Number = 0; i < recAC.length; i++){
						var sr:SearchResult = searchResultAC[i];
						sr.selected = false;
					}
				}
			}
			
			public function unhighlightDataGroupItems():void
			{
				if(widgetAndGridIteract){
					var recAC:ArrayCollection = searchResultDG.dataProvider as ArrayCollection;
					for (var i:Number = 0; i < recAC.length; i++){
						var sr:SearchResult = searchResultAC[i];
						if(sr.oid == sr.oid)
							sr.selected = false;
					}
				}
			}
			
			private function showHighlight(params:Array):void
			{
				var showHighlightPoint:MapPoint = params[0].point as MapPoint;
				popUpRenderer.popUpInfo = configurePopUpInfo(params[0].graphic.attributes.links);
				popUpRenderer.graphic = params[0].graphic;
				popUpRenderer.setStyle("skinClass", widgets.eSearch.PopUpRendererSkin);
				map.infoWindow.content = popUpRenderer;
				map.infoWindow.contentOwner = popUpRenderer.graphic;
				map.infoWindow.show(showHighlightPoint);
			}
			
			private function configurePopUpInfo(links:Array):PopUpInfo
			{
				var popUpInfo:PopUpInfo = new PopUpInfo;
				popUpInfo.title = "{title}";
				popUpInfo.description = "{content}";
				var pminfos:Array = [];
				
				for(var l:int=0; l<links.length; l++){
					if (links[l].link){
						var pos:Number = links[l].link.length - 4;
						var sfx:String = String(links[l].link).substr(pos, 4).toLowerCase();
						if ((sfx == ".jpg") || (sfx == ".png") || (sfx == ".gif")){ // use PopUpMediaInfo if it is an image
							var popUpMediaInfo:PopUpMediaInfo = new PopUpMediaInfo;
							popUpMediaInfo.type = PopUpMediaInfo.IMAGE;
							popUpMediaInfo.imageLinkURL = links[l].link;
							popUpMediaInfo.imageSourceURL = links[l].link;
							pminfos.push(popUpMediaInfo);
						}else{
							var lText:String = (links[l].alias != "") ? links[l].alias : links[l].link;
							popUpInfo.description += "<br /><a href='" + links[l].link + "'>" + lText + "</a>"
						}
					}
				}
				popUpInfo.popUpMediaInfos = pminfos;
				
				return popUpInfo;
			}
			
			private function showStateGraphicalSearch():void
			{
				lState = currentState;
				currentState = "graphicalInput";
			}
			
			private function showStateTextSearch():void
			{
				addSharedData("Deactivate_DrawTool", null);
				lState = currentState;
				currentState = "textInput";
			}				
			
			private function showStateResults():void
			{
				lState = currentState;
				currentState = "resultsList";
				if(configSearchText.length){
					if(configSpatialSearchLayers.length)
						wTemplate.selectedTitlebarButtonIndex = 4;
					else
						wTemplate.selectedTitlebarButtonIndex = 3;
				}else{
					if(configSpatialSearchLayers.length)
						wTemplate.selectedTitlebarButtonIndex = 3;
					else
						wTemplate.selectedTitlebarButtonIndex = 2;
				}
			}
			
			private function showStateSpatialSearch():void
			{
				lState = currentState;
				currentState = "spatialInput";
			}
			
			private function widgetClosedHandler(event:Event):void
			{
				setMapAction(null, null, null, null);
				graphicsLayer.visible = false;
				if(bufferGraphicsLayer)
					bufferGraphicsLayer.visible = false;
				if(graGraphicsLayer)
					graGraphicsLayer.visible = false;
				hideInfoWindow();
				setMapNavigation(null, null);
				
				if (selectedDrawingIcon)
					selectedDrawingIcon = null;
			}
			
			private function graphicsLayer_hideHandler(event:FlexEvent):void
			{
				hideInfoWindow();
			}
			
			private function sldrDataTipFormatter(value:Number):String 
			{ 
				return int(value * 100) + "%"; 
			}
			
			private function fnInit():void
			{
				cbSearch.addEventListener(ListEvent.ITEM_ROLL_OVER,fnCreToolTip);
				cbSearch.addEventListener(ListEvent.ITEM_ROLL_OUT,fnCreToolTip);
				cbSearch.addEventListener(ListEvent.CHANGE,fnCreToolTip);
			}
			
			private function fnCreToolTip(e:ListEvent):void
			{
				switch(e.type)
				{
					case ListEvent.ITEM_ROLL_OVER:{
						try{
							ToolTipManager.destroyToolTip(myTip);
						}
						catch(error:Error){}
						//creates a tooltip.
						myTip = ToolTipManager.createToolTip(cbSearch.dataProvider[e.rowIndex].label,stage.mouseX+10,stage.mouseY) as ToolTip; // array2 is id of arraylist  
						break;
					}
					case ListEvent.ITEM_ROLL_OUT:{
						//destroy the created tooltip, so that we can create a new one for others.
						try{
							ToolTipManager.destroyToolTip(myTip);
						}
						catch(error:Error){}
						break;
					}
					case ListEvent.CHANGE:{
						//destroy the created tooltip, so that we can create a new one for others.
						try{
							ToolTipManager.destroyToolTip(myTip);
						}
						catch(error:Error){}
						break;
					}
				}
			}
			
			private function zoomAll():void
			{
				if(resultsFeatureSet){
					if (resultsFeatureSet.features.length == 1 
						&& resultsFeatureSet.features[0].geometry.type == Geometry.MAPPOINT){
						var mp:MapPoint = resultsFeatureSet.features[0].geometry as MapPoint;
						map.zoom(1 / 16, mp);
						map.centerAt(mp);
					}else{
						var graphicsExtent:Extent = GraphicUtil.getGraphicsExtent(resultsFeatureSet.features);
						map.extent = graphicsExtent.expand(1.2);
						// make sure the whole extent is visible
						if (!map.extent.contains(graphicsExtent.expand(1.2)))
							map.level--;
					}
				}
			}
			
			private function geometryService_faultHandler(event:FaultEvent):void
			{
				Alert.show(event.fault.toString(), wTemplate.widgetTitle,4,wTemplate);
			}
			
			private function iconRollOverHandler(event:MouseEvent):void
			{
				clearSelectionFilter();
				event.target.filters = [ glowFilter ];
			}
			
			private function iconRollOutHandler(event:MouseEvent):void
			{
				clearSelectionFilter();
			}
			
			private function clearSelectionFilter():void
			{
				for (var i:int = 0; i < imageGroup.numChildren; i++){
					if (imageGroup.getChildAt(i).filters && imageGroup.getChildAt(i).filters.length > 0){
						if (!(selectedDrawingIcon && imageGroup.getChildAt(i) === selectedDrawingIcon)){
							if(imageGroup.getChildAt(i)!== eDrawBtn && imageGroup.getChildAt(i)!== pBufferBtn)
								imageGroup.getChildAt(i).filters = [];
						}
					}
				}
			}
			
			private function sharedDataUpdated(event:AppEvent):void
			{
				var data:Object = event.data;
				
				if (data.key == "Deactivate_DrawTool"){
					setMapAction(null, null, null, null);
					if (selectedDrawingIcon){
						selectedDrawingIcon.filters = [];
						selectedDrawingIcon = null;
					}
				}
			}
			
			private function hideInfoWindow():void
			{
				if (map.infoWindow.contentOwner &&
					((map.infoWindow.contentOwner is Graphic && Graphic(map.infoWindow.contentOwner).graphicsLayer === graphicsLayer) || map.infoWindow.contentOwner is Map))
					map.infoWindow.hide();
			}
			
			private function DisplayVersion(evt:MouseEvent):void
			{
				if(evt.altKey)
					Alert.show("Enhanched Search Widget Version: " + VERSION + "\nBuild Date: " + BUILDDATE, 
						wTemplate.widgetTitle,4,null,null,iconClass);
			}
		]]>
	</fx:Script>
	
	<viewer:WidgetTemplate id="wTemplate"
						   closed="widgetClosedHandler(event)" 
						   open="widgetOpenedHandler(event)"
						   width="400" height="240"
						   minHeight="160"
						   minWidth="210"
						   visible="false">
		<s:Group id="textInput"
				 width="100%" height="100%"
				 visible="false"
				 visible.textInput="true">
			<s:layout>
				<s:VerticalLayout gap="4" horizontalAlign="center"/>
			</s:layout>
			<s:HGroup id="boxText"
					  width="100%"
					  gap="15"
					  horizontalAlign="center" verticalAlign="middle">
				<s:Label id="lblLayerText" text="{layerLabel}"/>
				<mx:ComboBox id="cboLayerText" change="searchLayerChangedText()"/>
			</s:HGroup>
			<s:HGroup id="boxTextexpr"
					  width="100%"
					  gap="15"
					  horizontalAlign="center"  verticalAlign="middle">
				<s:Label id="lblExprText" text="{layerExprLabel}"/>
				<mx:ComboBox id="cboLayerExpr" change="searchLayerExprChangedText()"/>
			</s:HGroup>
			<s:RichEditableText id="txtLabelText"
			 		 selectable="true"
					 editable="false"
					 width="100%"
					 text=""
					 textAlign="center"/>
			<s:TextInput id="txtSearch" width="90%"/>
			<mx:ComboBox id="cbSearch" creationComplete="{cbSearch.width = wTemplate.width - 40; fnInit();}"
						 change="queryFeaturesText()" visible="false" includeInLayout="false" 
						 labelField="label"/>
			<s:HGroup width="100%" horizontalAlign="center"  verticalAlign="middle">
				<s:Button id="searchBtn" label="{submitLabel}"/>
				<s:Button click="clear()" label="{clearLabel}"/>
			</s:HGroup>
		</s:Group>
		<s:Group id="graphicalInput"
				 width="100%" height="100%"
				 visible="false"
				 visible.graphicalInput="true">
			<s:layout>
				<s:VerticalLayout gap="6" horizontalAlign="center"/>
			</s:layout>
			<s:HGroup id="boxGraphical"
					  width="100%"
					  gap="15"
					  horizontalAlign="center" verticalAlign="middle">
				<s:Label id="lblLayerGraphical" text="{layerLabel}"/>
				<mx:ComboBox id="cboLayerGraphical" change="searchLayerChangedGraphical()"/>
			</s:HGroup>
			<s:Label id="txtLabelGraphical"
					 width="100%"
					 text=""
					 textAlign="center"/>
			<s:HGroup id="imageGroup"
					  width="100%"
					  gap="10"
					  horizontalAlign="center">
				<mx:Image id="eDrawBtn"
						  width="40" height="40"
						  click="getDrawGra()"
						  source= "widgets/eSearch/assets/images/i_draw_draw.png"
						  toolTip="{drawGraLabel}" 
						  visible="{eDrawEnabled}"
						  includeInLayout="{eDrawEnabled}" />
				<mx:Image id="pBufferBtn"
						  width="40" height="40"
						  click="getBufferGra()"
						  source= "widgets/eSearch/assets/images/i_draw_buffer.png"
						  toolTip="{bufferGraLabel}" 
						  visible="{pBufferEnabled}"
						  includeInLayout="{pBufferEnabled}" />
				<mx:Image id="iSearchPnt"
						  name="{DrawTool.MAPPOINT}"
						  width="40" height="40"
						  buttonMode="true"
						  click="{activateSearchTool(event)}"
						  rollOut="iconRollOutHandler(event)"
						  rollOver="iconRollOverHandler(event)"
						  source="assets/images/i_draw_point.png"
						  toolTip="{pointLabel}"
						  useHandCursor="true"/>
				<mx:Image id="iSearchLine"
						  name="{DrawTool.POLYLINE}"
						  width="40" height="40"
						  buttonMode="true"
						  click="{activateSearchTool(event)}"
						  rollOut="iconRollOutHandler(event)"
						  rollOver="iconRollOverHandler(event)"
						  source="assets/images/i_draw_line.png"
						  toolTip="{lineLabel}"
						  useHandCursor="true"/>
				<mx:Image id="iSearchExt"
						  name="{DrawTool.EXTENT}"
						  width="40" height="40"
						  buttonMode="true"
						  click="{activateSearchTool(event)}"
						  rollOut="iconRollOutHandler(event)"
						  rollOver="iconRollOverHandler(event)"
						  source="assets/images/i_draw_rect.png"
						  toolTip="{rectangleLabel}"
						  useHandCursor="true"/>
				<mx:Image id="iSearchPoly"
						  name="{DrawTool.POLYGON}"
						  width="40" height="40"
						  buttonMode="true"
						  click="{activateSearchTool(event)}"
						  rollOut="iconRollOutHandler(event)"
						  rollOver="iconRollOverHandler(event)"
						  source="assets/images/i_draw_poly.png"
						  toolTip="{polygonLabel}"
						  useHandCursor="true"/>
			</s:HGroup>
			<s:HGroup width="100%"
					  horizontalAlign="right"
					  verticalAlign="middle"
					  paddingRight="10"
					  paddingTop="2" gap="10">
				<s:CheckBox id="graMultiChk" selected="{multiPartGraphicSearch}" label="{enableMultiPartSearch}" change="graMultiChanged()"/>
				<s:Button id="graFeatureQueryBtn" click="queryFeaturesGra()" label="{submitLabel}"/>
				<s:Label buttonMode="true"
						 click="clear()"
						 fontWeight="bold"
						 text="{clearLabel}"
						 textDecoration="underline"/>
			</s:HGroup>
			<s:CheckBox id="addTolerance" selected="{applyTolleranceByDefault}" label="{lblTolerance}"/>
			<s:HGroup verticalAlign="middle">
				<s:CheckBox id="bufferUserGraphic" selected="false" label="{lblbufferUserGraphic}"/>
				<s:TextInput id="textGraInputBuffer" text="50" width="40" />
				<mx:ComboBox id="cboGraBufferUnit" />
				<mx:ColorPicker id="cpGraBufferColor" selectedColor="#01b9fd" toolTip="{bufferColorLabel}" />
				<s:HSlider id="hsGraBufferAlpha" width="55" value="0.3" minimum="0" maximum="1" snapInterval="0.1"
						   toolTip="{bufferAlphaLabel}" dataTipFormatFunction="sldrDataTipFormatter"
						   skinClass="widgets.eSearch.alphaSliderSkin"/>
			</s:HGroup>
		</s:Group>
		<s:Group id="spatialInput"
				 width="100%" height="100%"
				 visible="false"
				 visible.spatialInput="true">
			<s:layout>
				<s:VerticalLayout gap="6" horizontalAlign="center"/>
			</s:layout>
			<s:Label id="lblBuffer" text="{bufferLabel}" width="100%"/>
			<s:HGroup verticalAlign="middle">
				<s:TextInput id="textInputBuffer" text="50" width="40" />
				<mx:ComboBox id="cboBufferUnit" />
				<mx:ColorPicker id="cpBufferColor" selectedColor="#01b9fd" toolTip="{bufferColorLabel}" />
				<s:HSlider id="hsBufferAlpha" width="55" value="0.3" minimum="0" maximum="1" snapInterval="0.1"
				toolTip="{bufferAlphaLabel}" dataTipFormatFunction="sldrDataTipFormatter"
			    skinClass="widgets.eSearch.alphaSliderSkin"/>
			</s:HGroup>
			<s:HGroup width="100%" gap="20" horizontalAlign="center" verticalAlign="middle">
				<mx:Image width="40" height="40"
						  buttonMode="true"
						  click="applyBuffer()"
						  source="widgets/eSearch/assets/images/i_buffer.png"
						  toolTip="{applyBufferLabel}"
						  useHandCursor="true"/>
				<mx:Image width="40" height="40"
						  buttonMode="true"
						  click="clearBuffer()"
						  source="assets/images/i_clear.png"
						  toolTip="{clearLabel}"
						  useHandCursor="true"/>
			</s:HGroup>	
			<s:Line xFrom="0" xTo="350" yFrom="0" yTo="0">
				<s:stroke>
					<s:SolidColorStroke color="0xFFFFFF" weight="1"/>
				</s:stroke>
			</s:Line>
			<s:Label id="lblSearchLayerSpatial" text="{searchLayerLabel}" width="100%"/>
			<mx:ComboBox id="cboSearchLayerSpatial"/>
			<s:HGroup id="SpatialOps" width="100%" gap="0" horizontalAlign="center" verticalAlign="middle" />		
		</s:Group>
		<!-- result-->
		<s:Group id="resultsList"
				 width="100%" height="100%"
				 visible="false"
				 visible.resultsList="true">
			<s:layout>
				<s:VerticalLayout gap="1"/>
			</s:layout>
			<s:HGroup id="boxMessage"
					  width="100%"
					  includeInLayout="{msgVisible}"
					  visible="{msgVisible}" verticalAlign="middle" horizontalAlign="center">
				<mx:Image id="swfMessage"
						  source="assets/images/loader.swf"
						  visible="false"/>
				<s:Label id="txtMessage"
						 width="90%"
						 text=""/>
				<s:Label buttonMode="true" textAlign="right"
						 click="zoomAll()"
						 fontWeight="bold"
						 includeInLayout="{graphicsLayer.numGraphics &gt; 0}"
						 text="{zoomallLabel}"
						 textDecoration="underline"
						 toolTip="{zoomallTip}"
						 visible="{graphicsLayer.numGraphics &gt; 0}"/>
				<s:Label buttonMode="true" textAlign="right"
						 click="clear()"
						 fontWeight="bold"
						 includeInLayout="{graphicsLayer.numGraphics &gt; 0}"
						 text="{clearLabel}"
						 textDecoration="underline"
						 visible="{graphicsLayer.numGraphics &gt; 0}"/>
			</s:HGroup>
			<s:Scroller id="recVbox" width="100%" height="100%">
				<Search:SearchResultDataGroup id="searchResultDG"
											  dataProvider="{searchResultAC}"
											  searchResultClick="clickSearchResult(event)"
											  searchResultMouseOut="mouseOutSearchResult(event)"
											  searchResultMouseOver="mouseOverSearchResult(event)"
											  searchResultRelateClick="clickSearchRelateResult(event)">
					<Search:layout>
						<s:VerticalLayout gap="2"
										  horizontalAlign="justify"
										  useVirtualLayout="true"/>
					</Search:layout>
				</Search:SearchResultDataGroup>
			</s:Scroller>
		</s:Group>
	</viewer:WidgetTemplate>
</viewer:BaseWidget>